---
title: "Today's Skins"
# VERSION: 2024-11-20-v1 (Show game times in CT for upcoming games instead of "Not Started")
format:
  html:
    self-contained: true
    theme: darkly
    grid:
      body-width: 1200px
    css: |
      table {
        width: auto !important;
        margin-left: auto;
        margin-right: auto;
      }
      /* Mobile-friendly improvements */
      @media (max-width: 768px) {
        table {
          font-size: 12px;
        }
        th, td {
          padding: 4px !important;
        }
        .table-responsive {
          overflow-x: auto;
          -webkit-overflow-scrolling: touch;
        }
      }
---

```{r setup}
#| echo: false
#| message: false
#| warning: false
# Load all required packages for the whole document
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rvest, httr, dplyr, tidyr, stringr, lubridate, tibble, knitr, kableExtra, readr, ggplot2)

# Create history directory - use relative path that works in both local and GitHub Actions
history_dir <- "skins_history"
if (!dir.exists(history_dir)) {
  dir.create(history_dir, recursive = TRUE)
}
```

```{r timestamp}
#| echo: false
#| results: 'asis'
ts <- format(Sys.time(), "%A, %B %d, %Y at %I:%M %p %Z", tz = "America/Chicago")
cat(paste0("<p style='font-size:14px; color:#999;'><strong>Last updated:</strong> ", ts, "</p>"))
```

```{r expected_skins_data}
#| echo: false
#| message: false
#| warning: false
# This chunk must run first (invisibly) to create 'todays_picks'
# for the results tables that now appear at the top.

# --- Part 0: Define Time and Data Source ---

# Get current time in Chicago
current_time_ct <- now(tzone = "America/Chicago")
current_hour_ct <- hour(current_time_ct)

# Define the "skins date" based on the 2 AM cutoff.
# A "day" runs from 2:00 AM to 1:59 AM the next morning.
if (current_hour_ct < 2) {
  # If it's 1 AM, it's still "yesterday's" skins date
  skins_date <- as_date(current_time_ct) - days(1)
} else {
  # If it's 2 AM or later, it's "today's" skins date
  skins_date <- as_date(current_time_ct)
}

# Use skins_date as the definitive date for this run
today_ct <- skins_date 
current_year <- year(today_ct)

# Define blackout window: 11 PM (23:00) to 1:59 AM
use_csv_for_sportsline <- current_hour_ct >= 23 | current_hour_ct < 2

# Define draft_data (needs to be available for both branches)
draft_data <- tribble(
  ~Team, ~Matchup_Key, ~abbr, ~skins_pick, ~player,
  "Utah Jazz", "Jazz|Utah", "UTA", "L", "Eristeo",
  "Oklahoma City Thunder", "Thunder|Oklahoma", "OKC", "W", "Matt",
  "Washington Wizards", "Wizards|Washington", "WAS", "L", "Brian",
  "Brooklyn Nets", "Nets|Brooklyn", "BKN", "L", "Adam",
  "Cleveland Cavaliers", "Cavaliers|Cleveland", "CLE", "W", "Thomas",
  "Charlotte Hornets", "Hornets|Charlotte", "CHA", "L", "Brian",
  "Denver Nuggets", "Nuggets|Denver", "DEN", "W", "Thomas",
  "New York Knicks", "Knicks|New York", "NYK", "W", "Adam",
  "Houston Rockets", "Rockets|Houston", "HOU", "W", "Kenneth",
  "Phoenix Suns", "Suns|Phoenix", "PHX", "L", "Eristeo",
  "New Orleans Pelicans", "Pelicans|New Orleans", "NOP", "L", "Matt",
  "Orlando Magic", "Magic|Orlando", "ORL", "W", "Kenneth",
  "Chicago Bulls", "Bulls|Chicago", "CHI", "L", "Thomas",
  "Los Angeles Clippers", "Clippers|LA Clippers", "LAC", "W", "Eristeo",
  "Minnesota Timberwolves", "Timberwolves|Minnesota", "MIN", "W", "Matt",
  "Portland Trail Blazers", "Trail Blazers|Portland", "POR", "L", "Kenneth",
  "Atlanta Hawks", "Hawks|Atlanta", "ATL", "W", "Adam",
  "Los Angeles Lakers", "Lakers|LA Lakers", "LAL", "W", "Adam",
  "Golden State Warriors", "Warriors|Golden State", "GSW", "W", "Kenneth",
  "Sacramento Kings", "Kings|Sacramento", "SAC", "L", "Thomas",
  "Detroit Pistons", "Pistons|Detroit", "DET", "W", "Brian",
  "Indiana Pacers", "Pacers|Indiana", "IND", "L", "Eristeo",
  "Miami Heat", "Heat|Miami", "MIA", "L", "Matt",
  "Philadelphia 76ers", "76ers|Philadelphia", "PHI", "W", "Matt",
  "Toronto Raptors", "Raptors|Toronto", "TOR", "L", "Brian",
  "Milwaukee Bucks", "Bucks|Milwaukee", "MIL", "W", "Brian",
  "San Antonio Spurs", "Spurs|San Antonio", "SAS", "W", "Eristeo",
  "Memphis Grizzlies", "Grizzlies|Memphis", "MEM", "W", "Kenneth",
  "Boston Celtics", "Celtics|Boston", "BOS", "W", "Adam",
  "Dallas Mavericks", "Mavericks|Dallas", "DAL", "W", "Thomas"
)

# --- Part 1: Get Data (Conditional) ---
if (use_csv_for_sportsline) {
  file_path <- file.path(history_dir, paste0(skins_date, ".csv"))
  
  if (file.exists(file_path)) {
    csv_data <- read_csv(file_path, show_col_types = FALSE)
    
    if ("game_id" %in% colnames(csv_data)) {
      todays_picks <- csv_data %>%
        mutate(
          "Expected Skins" = Expected_Skins,
          Moneyline = NA_real_,
          "Implied Prob" = NA_real_,
          Live_Expected_Skins = NA_real_,
          game_time_ct = as.POSIXct(NA)
        ) %>%
        select(Date, Team, Pick, "Expected Skins", Player, Moneyline, "Implied Prob", Abbr, game_id, Won_Game, Actual_Skins, Skins_Luck, Live_Expected_Skins, game_time_ct) %>%
        arrange(desc(`Expected Skins`))
        
    } else {
      use_csv_for_sportsline <- FALSE
    }
    
  } else {
    use_csv_for_sportsline <- FALSE
  }
}

if (!use_csv_for_sportsline) {
  # --- Part 1.1: Scrape Expected Odds ---
  url <- paste0("https://www.sportsline.com/nba/odds/money-line/",
                "?t=", format(Sys.time(), "%Y%m%d%H%M%S"))
  googlebot_ua <- "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html"
  page_session <- rvest::session(url, httr::user_agent(googlebot_ua))
  html_content <- rvest::read_html(page_session)
  game_data_raw <- html_content %>% html_element("table") %>% html_table()
  
  # Extract correct columns and clean team names
  game_data <- data.frame(
    Matchup_raw = game_data_raw[[1]],
    consensus = game_data_raw[[3]],
    stringsAsFactors = FALSE
  ) %>%
    mutate(
      # Remove the record (e.g., "2-1") from team names
      Matchup = str_remove(Matchup_raw, "\\d+-\\d+$")
    )

  # --- Part 1.2: Calculate Expected Skins ---
  convert_odds_to_prob <- function(odds) {
    prob <- case_when(
      odds < 0 ~ abs(odds) / (abs(odds) + 100),
      odds > 0 ~ 100 / (odds + 100),
      TRUE ~ NA_real_
    )
    return(prob)
  }
  
  # FIXED: Use word boundaries to prevent "Hornets" from matching "Nets"
  match_team <- function(matchup_str, draft_data) {
    matchup_upper <- str_to_upper(matchup_str)
    for (i in 1:nrow(draft_data)) {
      keys <- str_split(draft_data$Matchup_Key[i], "\\|")[[1]]
      keys_upper <- str_to_upper(keys)
      
      # Check if any of the keys match (with word boundaries)
      for (key in keys_upper) {
        pattern <- paste0("\\b", key, "\\b")
        if (str_detect(matchup_upper, regex(pattern))) {
          return(draft_data$Matchup_Key[i])
        }
      }
    }
    return(NA_character_)
  }
  
  # Parse based on actual structure
  todays_picks <- game_data %>%
    filter(!is.na(Matchup) & Matchup != "") %>%
    mutate(
      row_id = row_number(),
      game_time_str = str_extract(Matchup_raw, 
        "(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+\\d+,\\s+\\d+:\\d+\\s*[AP]M\\s+UTC")
    ) %>%
    # Fill UP because date rows come AFTER team rows
    fill(game_time_str, .direction = "up") %>%
    # Filter out the "Expert Picks" and "Advanced Insights" rows
    filter(!str_detect(Matchup, "Expert Picks|Advanced Insights")) %>%
    # Only keep rows with actual odds (contains +/- numbers)
    filter(str_detect(consensus, "[+-]\\d+")) %>%
    mutate(
      Matchup_Key = vapply(Matchup, match_team, draft_data = draft_data, FUN.VALUE = character(1)),
      game_time_str_with_year = paste(game_time_str, current_year),
      game_time_utc = parse_date_time(
        str_remove(game_time_str_with_year, "\\s+UTC"),
        orders = c("b d, I:M p Y"),
        tz = "UTC"
      ),
      game_time_ct = with_tz(game_time_utc, tzone = "America/Chicago"),
      game_date_ct = as_date(game_time_ct),
      # Create game_id: every 2 consecutive rows are a game
      game_id = paste0(game_date_ct, "_", ceiling(row_number() / 2))
    ) %>%
    # *** THIS IS THE KEY FILTER ***
    # It now filters for games matching the "skins_date" (which is today_ct)
    filter(game_date_ct == today_ct, !is.na(Matchup_Key)) %>%
    mutate(
      # Extract odds from format like "-175Open: -189"
      moneyline = as.numeric(str_extract(consensus, "^[+-]?\\d+")),
      opening_odds = as.numeric(str_extract(consensus, "(?<=Open: )[+-]?\\d+"))
    ) %>%
    # Remove duplicates - keep one row per team per game
    distinct(Matchup_Key, game_id, .keep_all = TRUE) %>%
    mutate(implied_prob = convert_odds_to_prob(moneyline)) %>%
    group_by(game_id) %>%
    mutate(
      total_prob_in_game = sum(implied_prob, na.rm = TRUE),
      prob_no_vig = implied_prob / total_prob_in_game
    ) %>%
    ungroup() %>%
    left_join(draft_data, by = "Matchup_Key") %>%
    filter(!is.na(Team)) %>%
    mutate(
      expected_skins = if_else(skins_pick == "W", prob_no_vig, 1 - prob_no_vig),
      Date = today_ct,
      Won_Game = NA,
      Actual_Skins = NA_real_,
      Skins_Luck = NA_real_,
      Live_Expected_Skins = NA_real_
    ) %>%
    select(Date, Team, Pick = skins_pick, "Expected Skins" = expected_skins,
           Player = player, Moneyline = moneyline, "Implied Prob" = prob_no_vig,
           Abbr = abbr, game_id, Won_Game, Actual_Skins, Skins_Luck, Live_Expected_Skins, game_time_ct) %>%
    arrange(desc(`Expected Skins`))
}

# --- Part 2: Handle Draft Data Mismatch ---
# (This runs for both CSV and Scrape methods)
if (nrow(todays_picks) > 0) {
  teams_in_picks <- unique(todays_picks$Team)
  teams_in_draft <- unique(draft_data$Team)
  
  # Teams that are in picks but not in draft (indicates a mismatch in draft_data)
  unmatched_teams_in_picks <- setdiff(teams_in_picks, teams_in_draft)
  if (length(unmatched_teams_in_picks) > 0) {
    cat("WARNING: Teams in scraped data but not in draft_data:", 
        paste(unmatched_teams_in_picks, collapse = ", "), "\n")
  }
}
```

```{r scrape_live_data}
#| echo: false
#| message: false
#| warning: false

# This chunk scrapes live win probabilities from gambletron
# and joins them with our 'todays_picks' data.

# Initialize diagnostics list
gambletron_diagnostics <- list()

# Always scrape live data regardless of blackout window
# --- Define URLs ---
url_live <- "https://www.gambletron2000.com/live?sport=nba&team="
url_inactive <- "https://www.gambletron2000.com/inactive?sport=nba&s=start_time&team="

# --- 1. Scrape "Live!" Games ---
tryCatch({
  response_live <- GET(url_live, user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"))
  webpage_live <- read_html(response_live)
  
  live_nodes <- webpage_live %>% html_elements("li.event-summary")
  
  live_games <- live_nodes %>%
    lapply(function(node) {
      # ENHANCED: More robust extraction with error handling
      teams_text <- tryCatch({
        node %>% 
          html_element("span.team") %>% 
          html_text2() %>% 
          trimws()
      }, error = function(e) NA_character_)
      
      teams <- if (!is.na(teams_text)) strsplit(teams_text, "\n")[[1]] else c(NA, NA)
      
      # CRITICAL FIX: Extract probabilities more carefully
      prob_elements <- node %>% html_elements("span.pull-right")
      probs <- if (length(prob_elements) >= 2) {
        prob_elements %>% 
          html_text() %>% 
          trimws() %>%
          head(2)  # Take only first 2 probabilities
      } else {
        c(NA_character_, NA_character_)
      }
      
      data.frame(
        status = "Live",
        team_1 = if(length(teams) >= 1) trimws(teams[1]) else NA_character_,
        team_2 = if(length(teams) >= 2) trimws(teams[2]) else NA_character_,
        team_1_prob = if(length(probs) >= 1) probs[1] else NA_character_,
        team_2_prob = if(length(probs) >= 2) probs[2] else NA_character_,
        game_date = NA_character_,
        sport = tryCatch({
          trimws(html_element(node, ".sport .sport-emoji") %>% html_attr("alt"))
        }, error = function(e) NA_character_)
      )
    }) %>%
    bind_rows()
  
  gambletron_diagnostics$live_games_count <- nrow(live_games)
  gambletron_diagnostics$live_games_raw <- live_games
}, error = function(e) {
  live_games <- data.frame()
  gambletron_diagnostics$live_scrape_error <- as.character(e)
})

# --- 2. Scrape "Inactive" Games (Starting Later & Finished) ---
tryCatch({
  response_inactive <- GET(url_inactive, user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"))
  webpage_inactive <- read_html(response_inactive)
  
  # --- 2a. Parse "Starting Later" ---
  starting_later_nodes <- webpage_inactive %>% 
    html_elements("#later-container a.event-link")
  
  starting_later_games <- starting_later_nodes %>%
    lapply(function(node) {
      data.frame(
        status = "Starting Later",
        team_1 = trimws(html_element(node, ".team .away") %>% html_text()),
        team_2 = trimws(html_element(node, ".team .home") %>% html_text()),
        team_1_prob = trimws(html_element(node, ".prob .away") %>% html_text()),
        team_2_prob = trimws(html_element(node, ".prob .home") %>% html_text()),
        game_date = trimws(html_element(node, ".event-time .gt-timestamp") %>% html_text()),
        sport = trimws(html_element(node, ".sport .sport-emoji") %>% html_attr("alt"))
      )
    }) %>%
    bind_rows()
  
  gambletron_diagnostics$starting_later_count <- nrow(starting_later_games)
  gambletron_diagnostics$starting_later_raw <- starting_later_games
  
  # --- 2b. Parse "Finished" ---
  finished_nodes <- webpage_inactive %>% 
    html_elements("#earlier-container a.event-link")
  
  finished_games <- finished_nodes %>%
    lapply(function(node) {
      team_1_is_winner <- !is.na(html_element(node, ".team .away.winner"))
      team_2_is_winner <- !is.na(html_element(node, ".team .home.winner"))
      
      data.frame(
        status = "Finished",
        team_1 = trimws(html_element(node, ".team .away") %>% html_text()),
        team_2 = trimws(html_element(node, ".team .home") %>% html_text()),
        team_1_prob = if_else(team_1_is_winner, "100%", if_else(team_2_is_winner, "0%", NA_character_)),
        team_2_prob = if_else(team_2_is_winner, "100%", if_else(team_1_is_winner, "0%", NA_character_)),
        game_date = trimws(html_element(node, ".event-time .gt-timestamp") %>% html_text()),
        sport = trimws(html_element(node, ".sport .sport-emoji") %>% html_attr("alt"))
      )
    }) %>%
    bind_rows()
  
  gambletron_diagnostics$finished_games_count <- nrow(finished_games)
  gambletron_diagnostics$finished_games_raw <- finished_games
}, error = function(e) {
  starting_later_games <- data.frame()
  finished_games <- data.frame()
  gambletron_diagnostics$inactive_scrape_error <- as.character(e)
})

# --- 3. Combine all data ---
all_games <- bind_rows(live_games, starting_later_games, finished_games)

# --- 4. Define "today" ---
m <- sub("^0", "", format(skins_date, "%m"))  # FIXED: Use skins_date instead of Sys.Date()
d <- sub("^0", "", format(skins_date, "%d"))  # FIXED: Use skins_date instead of Sys.Date()
today_date <- paste(m, d, sep="/")

gambletron_diagnostics$today_date_string <- today_date
gambletron_diagnostics$skins_date <- as.character(skins_date)

# --- 5. Filter for NBA and Today ---
# CRITICAL FIX: Only include finished games if they have today's date
nba_today <- all_games %>%
  filter(
    !is.na(sport),
    sport == "NBA",
    (status == "Live" | 
     (status == "Starting Later" & game_date == today_date) |
     (status == "Finished" & game_date == today_date))  # FIXED: Only include finished games from today
  )

gambletron_diagnostics$nba_today_count <- nrow(nba_today)
gambletron_diagnostics$nba_today_data <- nba_today

# --- 6. Process and Join Scraped Data ---
if (nrow(nba_today) > 0 && nrow(todays_picks) > 0) {
  # Convert probabilities from "XX%" string to numeric (vectorized)
  convert_prob_to_num <- function(prob_str) {
    # Handle vector input
    num_val <- as.numeric(str_remove(prob_str, "%")) / 100.0
    # Return NA for invalid probabilities, otherwise return the numeric value
    ifelse(is.na(num_val) | num_val < 0 | num_val > 1, NA_real_, num_val)
  }
  
  # Process each game as a pair to maintain complementary probabilities
  nba_today_with_ids <- nba_today %>%
    mutate(
      game_pair_id = row_number(),
      prob_1_num = convert_prob_to_num(team_1_prob),
      prob_2_num = convert_prob_to_num(team_2_prob)
    )
  
  # Validate and normalize probabilities for each game
  nba_today_normalized <- nba_today_with_ids %>%
    mutate(
      prob_sum = prob_1_num + prob_2_num,
      # Only normalize if both probabilities exist and sum is reasonable (0.8 to 1.2)
      needs_normalization = !is.na(prob_1_num) & !is.na(prob_2_num) & 
                            prob_sum > 0.8 & prob_sum < 1.2 & 
                            abs(prob_sum - 1.0) > 0.02,
      prob_1_normalized = case_when(
        is.na(prob_1_num) ~ NA_real_,
        needs_normalization ~ prob_1_num / prob_sum,
        TRUE ~ prob_1_num
      ),
      prob_2_normalized = case_when(
        is.na(prob_2_num) ~ NA_real_,
        needs_normalization ~ prob_2_num / prob_sum,
        TRUE ~ prob_2_num
      )
    )
  
  # ADDITIONAL VALIDATION: Remove finished games with 100%/0% for upcoming games
  nba_today_validated <- nba_today_normalized %>%
    mutate(
      # Flag suspicious finished game data - if status is "Finished" but game_date is today
      # and the game hasn't actually finished according to plaintextsports
      is_suspicious = (status == "Finished" & 
                      game_date == today_date &
                      ((prob_1_normalized == 1 & prob_2_normalized == 0) |
                       (prob_1_normalized == 0 & prob_2_normalized == 1)))
    )
  
  gambletron_diagnostics$suspicious_finished_games <- nba_today_validated %>%
    filter(is_suspicious == TRUE) %>%
    select(team_1, team_2, status, game_date, prob_1_normalized, prob_2_normalized)
  
  # Create one row per team with standardized names
  live_data_team1 <- nba_today_validated %>%
    select(Team = team_1, live_win_prob = prob_1_normalized, game_pair_id, status, is_suspicious)
  
  live_data_team2 <- nba_today_validated %>%
    select(Team = team_2, live_win_prob = prob_2_normalized, game_pair_id, status, is_suspicious)
  
  live_data_combined <- bind_rows(live_data_team1, live_data_team2) %>%
    mutate(Team = trimws(Team)) %>%
    filter(!is.na(Team), Team != "")
  
  # Standardize team names
  standardize_team_name <- function(team_name) {
    team_upper <- str_to_upper(team_name)
    
    # Check against all teams in draft_data
    for (i in 1:nrow(draft_data)) {
      keys <- str_split(draft_data$Matchup_Key[i], "\\|")[[1]]
      for (key in keys) {
        key_upper <- str_to_upper(key)
        # Use word boundaries for matching
        pattern <- paste0("\\b", key_upper, "\\b")
        if (str_detect(team_upper, regex(pattern))) {
          return(draft_data$Team[i])
        }
      }
      
      # Also try matching against the full team name
      if (str_detect(team_upper, str_to_upper(draft_data$Team[i]))) {
        return(draft_data$Team[i])
      }
      
      # Try matching against abbreviation
      if (team_upper == draft_data$abbr[i]) {
        return(draft_data$Team[i])
      }
    }
    
    # If no match found, return original
    return(team_name)
  }
  
  live_data_standardized <- live_data_combined %>%
    mutate(
      Team_Original = Team,
      Team = sapply(Team, standardize_team_name)
    )
  
  # For each standardized team, keep the most reliable probability
  # Prioritize: Live > Starting Later > (Don't use suspicious Finished)
  live_data_final <- live_data_standardized %>%
    mutate(
      status_priority = case_when(
        status == "Live" ~ 1,
        status == "Starting Later" ~ 2,
        status == "Finished" & is_suspicious == FALSE ~ 3,
        TRUE ~ 999  # Exclude suspicious finished games
      )
    ) %>%
    filter(status_priority < 999) %>%  # Exclude suspicious data
    arrange(Team, status_priority) %>%
    group_by(Team) %>%
    filter(!is.na(live_win_prob)) %>%
    slice(1) %>%
    ungroup() %>%
    select(Team, live_win_prob, status)
  
  gambletron_diagnostics$live_data_final <- live_data_final
  
  # Join with todays_picks
  todays_picks <- todays_picks %>%
    left_join(live_data_final, by = "Team") %>%
    mutate(
      Live_Expected_Skins = case_when(
        is.na(live_win_prob) ~ `Expected Skins`,  # Default to Expected Skins if no live data
        Pick == "W" ~ live_win_prob,
        Pick == "L" ~ 1 - live_win_prob,
        TRUE ~ `Expected Skins`
      )
    ) %>%
    select(-live_win_prob, -status)
  
  # ADDITIONAL FIX: For teams in the same game, ensure consistent probabilities
  # This helps when one team's probability was scraped but the other wasn't
  todays_picks <- todays_picks %>%
    group_by(game_id) %>%
    mutate(
      n_teams_in_game = n(),
      n_with_live_data = sum(Live_Expected_Skins != `Expected Skins`),
      # If only one team has live data but there are 2 teams, copy to the other
      should_share = n_teams_in_game == 2 & n_with_live_data == 1
    ) %>%
    mutate(
      Live_Expected_Skins = if_else(
        should_share & Live_Expected_Skins == `Expected Skins`,
        first(Live_Expected_Skins[Live_Expected_Skins != `Expected Skins`]),
        Live_Expected_Skins
      )
    ) %>%
    ungroup() %>%
    select(-n_teams_in_game, -n_with_live_data, -should_share)
}

# Ensure Live_Expected_Skins column exists even if scraping was skipped
if (!"Live_Expected_Skins" %in% names(todays_picks)) {
  todays_picks <- todays_picks %>%
    mutate(Live_Expected_Skins = `Expected Skins`)
}
```

```{r results_and_luck}
#| echo: false
#| message: false
#| warning: false

# Only process results if we have games today
if (nrow(todays_picks) > 0) {
  
  # Always scrape plaintextsports regardless of blackout window
  # 1. Scrape plaintextsports.com for live game data
  url_scores <- "https://plaintextsports.com/nba/"
  page_scores <- read_html(url_scores)
  
  # Get all text from the body
  all_text <- page_scores %>%
    html_element("body") %>%
    html_text2()
  
  # 2. Extract Game Blocks - Split into lines and get score boxes
  all_lines <- strsplit(all_text, "\n")[[1]]
  score_boxes <- all_lines[grepl("^\\+", all_lines)]
  
  # 3. Parse a single game box
  parse_game_box <- function(box) {
    # Split by "|" character
    parts <- strsplit(box, "\\|")[[1]]
    
    # Extract status, teams, and scores
    status <- str_trim(parts[2])
    
    # Team 1
    team1_line <- str_trim(parts[4])
    team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
    team1_score <- suppressWarnings(as.numeric(str_extract(team1_line, "[0-9]+$")))
    
    # Team 2
    team2_line <- str_trim(parts[6])
    team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
    team2_score <- suppressWarnings(as.numeric(str_extract(team2_line, "[0-9]+$")))
    
    # Determine if final
    is_final <- grepl("Final", status, fixed = TRUE)
    
    # FIXED: Determine if game is in progress - only match quarter/half/OT indicators, not scheduled times
    is_in_progress <- grepl("Q[1-4]|Half|OT", status) & !is_final
    
    # Return data frame
    data.frame(
      Team1 = team1_name,
      Team2 = team2_name,
      Score1 = team1_score,
      Score2 = team2_score,
      Status = status,
      Finished = is_final,
      InProgress = is_in_progress,
      stringsAsFactors = FALSE
    )
  }
  
  # 4. Parse all game boxes
  if (length(score_boxes) > 0) {
    all_game_results <- bind_rows(lapply(score_boxes, parse_game_box))
  } else {
    all_game_results <- data.frame()
  }
  
  # 5. Standardize team abbreviations to match draft_data
  team_replacements <- c(
    "^GS$" = "GSW",
    "^NO$" = "NOP",
    "^NY$" = "NYK",
    "^SA$" = "SAS",
    "^WSH$" = "WAS"
  )
  
  # Apply standardization
  if (nrow(all_game_results) > 0) {
    all_game_results <- all_game_results %>%
      mutate(
        Team1 = str_replace_all(Team1, team_replacements),
        Team2 = str_replace_all(Team2, team_replacements)
      )
  }
  
  # 6. Create Won_Game lookup - only for finished games
  final_team_results <- data.frame(Abbr = character(), Won_Game = logical(), stringsAsFactors = FALSE)
  
  if (nrow(all_game_results) > 0) {
    finished_games <- all_game_results %>% filter(Finished == TRUE)
    
    if (nrow(finished_games) > 0) {
      # Team 1 results
      team1_results <- finished_games %>%
        select(Abbr = Team1, PTS = Score1, Opp_PTS = Score2) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      # Team 2 results
      team2_results <- finished_games %>%
        select(Abbr = Team2, PTS = Score2, Opp_PTS = Score1) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      final_team_results <- bind_rows(team1_results, team2_results) %>%
        select(Abbr, Won_Game)
    }
  }
  
  # 6. Create todays_results with actual outcomes
  todays_results <- todays_picks %>%
    left_join(final_team_results, by = "Abbr", suffix = c("", "_new")) %>%
    mutate(
      Won_Game = coalesce(Won_Game_new, Won_Game),
      Actual_Skins = case_when(
        Won_Game == TRUE & Pick == "W" ~ 1,
        Won_Game == FALSE & Pick == "L" ~ 1,
        is.na(Won_Game) ~ NA_real_,
        TRUE ~ 0
      ),
      Skins_Luck = Actual_Skins - `Expected Skins`
    ) %>%
    select(-Won_Game_new)
  
  # 7. Save today's results to file (use underscores for easier CSV handling)
  # This now correctly uses today_ct (which is skins_date) as the filename
  today_file <- file.path(history_dir, paste0(today_ct, ".csv"))
  
  todays_results %>%
    select(
      Date, Player, Team, Abbr, Pick, 
      Expected_Skins = `Expected Skins`, 
      Won_Game, Actual_Skins, Skins_Luck,
      game_id
    ) %>%
    write_csv(today_file)
} else {
  todays_results <- data.frame()
}
```

---

## Daily Summary

```{r final_player_summary}
#| echo: false
#| message: false
#| warning: false

# Print Final Player Summary
if (exists("todays_results") && nrow(todays_results) > 0) {
  
  # Calculate cumulative live expected skins
  todays_results_with_cumulative <- todays_results %>%
    mutate(
      Cumulative_Live_Expected = if_else(!is.na(Won_Game), Actual_Skins, Live_Expected_Skins)
    )
  
  # Identify self zero-sum matchups (same player, both teams in same game)
  self_zero_sum_players <- todays_results_with_cumulative %>%
    group_by(game_id, Player) %>%
    filter(n() >= 2) %>%
    pull(Player) %>%
    unique()
  
  # Calculate Perfect Skins % for each player
  perfect_skins_calc <- todays_results_with_cumulative %>%
    group_by(Player) %>%
    summarise(
      num_games = n(),
      perfect_prob = prod(Cumulative_Live_Expected, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    mutate(
      `Perfect Skins %` = case_when(
        # If player has self zero-sum matchup, 0%
        Player %in% self_zero_sum_players ~ 0,
        # If player has less than 5 games, 0%
        num_games < 5 ~ 0,
        # Otherwise, multiply live expected skins probabilities and convert to %
        TRUE ~ perfect_prob * 100
      )
    ) %>%
    select(Player, `Perfect Skins %`)
  
  final_player_summary <- todays_results_with_cumulative %>%
    group_by(Player) %>%
    summarise(
      `Total Expected Skins` = sum(`Expected Skins`, na.rm = TRUE),
      `Live Expected Skins` = sum(Cumulative_Live_Expected, na.rm = TRUE),
      `Total Actual Skins` = sum(Actual_Skins, na.rm = TRUE),
      `Skins Luck` = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    mutate(
      `Live Skins Luck` = `Live Expected Skins` - `Total Expected Skins`
    ) %>%
    left_join(perfect_skins_calc, by = "Player") %>%
    # Calculate Luck Leverage column (whole number with % symbol)
    mutate(
      `Luck Leverage` = if_else(
        `Total Expected Skins` == 0, 
        "0%", 
        paste0(sprintf("%.0f", (`Live Skins Luck` / `Total Expected Skins`) * 100), "%")
      )
    ) %>%
    # CHANGED: Order by Live Skins Luck (descending)
    arrange(desc(`Live Skins Luck`)) %>%
    mutate(
      # Apply color coding to Player column
      Player_Display = case_when(
        `Skins Luck` > 0 ~ 
          cell_spec(Player, background = "#90EE90", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        `Skins Luck` < 0 ~ 
          cell_spec(Player, background = "#FFB6C6", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player
      ),
      # Apply color coding to Live Skins Luck column - exclude values between -0.1 and 0.1
      `Live Skins Luck Display` = case_when(
        `Live Skins Luck` > 0.1 ~ 
          cell_spec(sprintf("%.1f", `Live Skins Luck`), background = "#90EE90", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        `Live Skins Luck` < -0.1 ~ 
          cell_spec(sprintf("%.1f", `Live Skins Luck`), background = "#FFB6C6", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ as.character(sprintf("%.1f", `Live Skins Luck`))
      ),
      # Format Perfect Skins % with % symbol
      `Perfect Skins % Display` = paste0(sprintf("%.1f", `Perfect Skins %`), "%")
    ) %>%
    select(
      Player = Player_Display,
      `Live Skins Luck` = `Live Skins Luck Display`,
      `Luck Leverage`,
      `Total Expected Skins`,
      `Live Expected Skins`,
      `Total Actual Skins`,
      `Skins Luck`,
      `Perfect Skins %` = `Perfect Skins % Display`
    )
  
  # Add TOTAL row
  total_row <- data.frame(
    Player = "TOTAL",
    `Live Skins Luck` = sprintf("%.1f", sum(todays_results_with_cumulative$Cumulative_Live_Expected, na.rm = TRUE) - 
                         sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE)),
    `Luck Leverage` = if_else(
      sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE) == 0,
      "0%",
      paste0(sprintf("%.0f", ((sum(todays_results_with_cumulative$Cumulative_Live_Expected, na.rm = TRUE) - 
        sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE)) / 
       sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE)) * 100), "%")
    ),
    `Total Expected Skins` = sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE),
    `Live Expected Skins` = sum(todays_results_with_cumulative$Cumulative_Live_Expected, na.rm = TRUE),
    `Total Actual Skins` = sum(todays_results_with_cumulative$Actual_Skins, na.rm = TRUE),
    `Skins Luck` = sum(todays_results_with_cumulative$Skins_Luck, na.rm = TRUE),
    `Perfect Skins %` = paste0(sprintf("%.1f", sum(perfect_skins_calc$`Perfect Skins %`, na.rm = TRUE)), "%"),
    check.names = FALSE,
    stringsAsFactors = FALSE
  )
  
  final_player_summary_with_total <- bind_rows(final_player_summary, total_row)
  
  knitr::kable(
    final_player_summary_with_total,
    digits = 1,
    align = 'c',
    escape = FALSE,
    format = "html"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(c(2, 3, 7, 8), bold = TRUE) %>%
    row_spec(nrow(final_player_summary_with_total), bold = TRUE, background = "#444444")
}
```

---

## Today's Results & Skins Luck

```{r matchup_table}
#| echo: false
#| message: false
#| warning: false

# Create Head-to-Head Matchup Table
if (nrow(todays_picks) > 0) {
  
  # Scrape plaintextsports.com for game results
  url_scores <- "https://plaintextsports.com/nba/"
  page_scores <- read_html(url_scores)
  
  # Get all text
  all_text <- page_scores %>%
    html_element("body") %>%
    html_text2()
  
  # Extract score boxes
  all_lines <- strsplit(all_text, "\n")[[1]]
  score_boxes <- all_lines[grepl("^\\+", all_lines)]
  
  # Parse game boxes
  parse_game_box <- function(box) {
    parts <- strsplit(box, "\\|")[[1]]
    status <- str_trim(parts[2])
    
    team1_line <- str_trim(parts[4])
    team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
    team1_score <- suppressWarnings(as.numeric(str_extract(team1_line, "[0-9]+$")))
    
    team2_line <- str_trim(parts[6])
    team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
    team2_score <- suppressWarnings(as.numeric(str_extract(team2_line, "[0-9]+$")))
    
    is_final <- grepl("Final", status, fixed = TRUE)
    
    # FIXED: Determine if game is in progress - only match quarter/half/OT indicators, not scheduled times
    is_in_progress <- grepl("Q[1-4]|Half|OT", status) & !is_final
    
    data.frame(
      Team1 = team1_name,
      Team2 = team2_name,
      Score1 = team1_score,
      Score2 = team2_score,
      Status = status,
      Finished = is_final,
      InProgress = is_in_progress,
      stringsAsFactors = FALSE
    )
  }
  
  # Parse all games
  if (length(score_boxes) > 0) {
    matchup_game_results <- bind_rows(lapply(score_boxes, parse_game_box))
  } else {
    matchup_game_results <- data.frame()
  }
  
  # Standardize abbreviations: Map scraped names to draft_data names
  team_replacements <- c(
    "^GS$" = "GSW",
    "^NO$" = "NOP",
    "^NY$" = "NYK",
    "^SA$" = "SAS",
    "^WSH$" = "WAS"
  )
  
  if (nrow(matchup_game_results) > 0) {
    matchup_game_results <- matchup_game_results %>%
      mutate(
        Team1 = str_replace_all(Team1, team_replacements),
        Team2 = str_replace_all(Team2, team_replacements)
      )
  }
  
  # Create Won_Game lookup - only final games
  matchup_won_lookup <- data.frame(Abbr = character(), Won_Game = logical(), stringsAsFactors = FALSE)
  matchup_status_lookup <- data.frame(Abbr = character(), GameStatus = character(), stringsAsFactors = FALSE)
  # FIXED: Create score lookup ONLY for games that are in progress or finished
  matchup_score_lookup <- data.frame(Abbr = character(), Score = character(), stringsAsFactors = FALSE)
  
  if (nrow(matchup_game_results) > 0) {
    # Won_Game lookup for finished games
    finished_games <- matchup_game_results %>% filter(Finished == TRUE)
    
    if (nrow(finished_games) > 0) {
      team_1 <- finished_games %>%
        select(Abbr = Team1, PTS = Score1, Opp_PTS = Score2) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      team_2 <- finished_games %>%
        select(Abbr = Team2, PTS = Score2, Opp_PTS = Score1) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      matchup_won_lookup <- bind_rows(team_1, team_2) %>%
        select(Abbr, Won_Game)
    }
    
    # Status lookup for all games
    all_games_status <- matchup_game_results %>%
      mutate(
        GameStatus = case_when(
          Finished == TRUE ~ "Final",
          InProgress == TRUE ~ str_remove(Status, "^(WA|WB|WC|WD|EA|EB|EC|ED)\\s+"),
          TRUE ~ Status  # Keep original Status for upcoming games (contains game time)
        )
      )
    
    team_1_status <- all_games_status %>%
      select(Abbr = Team1, GameStatus)
    
    team_2_status <- all_games_status %>%
      select(Abbr = Team2, GameStatus)
    
    matchup_status_lookup <- bind_rows(team_1_status, team_2_status) %>%
      distinct()
    
    # FIXED: Score lookup ONLY for games that are in progress or finished
    games_with_scores <- matchup_game_results %>%
      filter((InProgress == TRUE | Finished == TRUE) & !is.na(Score1) & !is.na(Score2))
    
    if (nrow(games_with_scores) > 0) {
      team_1_scores <- games_with_scores %>%
        mutate(Score = paste0(Score1, "-", Score2)) %>%
        select(Abbr = Team1, Score)
      
      team_2_scores <- games_with_scores %>%
        mutate(Score = paste0(Score2, "-", Score1)) %>%
        select(Abbr = Team2, Score)
      
      matchup_score_lookup <- bind_rows(team_1_scores, team_2_scores) %>%
        distinct()
    }
  }
  
  # Update todays_picks with Won_Game, GameStatus, and Score
  todays_picks <- todays_picks %>%
    left_join(matchup_won_lookup, by = "Abbr", suffix = c("", "_new")) %>%
    left_join(matchup_status_lookup, by = "Abbr") %>%
    left_join(matchup_score_lookup, by = "Abbr") %>%
    mutate(
      Won_Game = coalesce(Won_Game_new, Won_Game),
      Won_Skin = case_when(
        Won_Game == TRUE & Pick == "W" ~ TRUE,
        Won_Game == FALSE & Pick == "L" ~ TRUE,
        is.na(Won_Game) ~ NA,
        TRUE ~ FALSE
      ),
      Game_Status = GameStatus,
      Game_Score = if_else(is.na(Score), "", Score)
    ) %>%
    select(-Won_Game_new, -GameStatus, -Score)
  
  # Build the matchup table - ONE ROW PER GAME
  matchup_prep <- todays_picks %>%
    mutate(
      # IMPROVED: Use first non-NA value for cumulative calculation
      Cumulative_Live_Expected = case_when(
        !is.na(Won_Game) ~ Actual_Skins,
        !is.na(Live_Expected_Skins) ~ Live_Expected_Skins,
        TRUE ~ `Expected Skins`  # Fallback to Expected if Live is also NA
      )
    ) %>%
    arrange(game_id)
  
  # Create one row per game with both players
  matchup_table <- matchup_prep %>%
    group_by(game_id) %>%
    summarise(
      Player_1 = first(Player),
      Team_1 = first(Team),
      Pick_1 = first(Pick),
      Won_Skin_1 = first(Won_Skin),
      # IMPROVED: Get first non-NA live expected skins
      Live_Skin_Prob_1 = coalesce(first(Cumulative_Live_Expected), first(`Expected Skins`)),
      Score_1 = first(Game_Score),
      Player_2 = if(n() > 1) nth(Player, 2) else NA_character_,
      Team_2 = if(n() > 1) nth(Team, 2) else NA_character_,
      Pick_2 = if(n() > 1) nth(Pick, 2) else NA_character_,
      Won_Skin_2 = if(n() > 1) nth(Won_Skin, 2) else NA,
      # IMPROVED: Get second non-NA live expected skins
      Live_Skin_Prob_2 = if(n() > 1) coalesce(nth(Cumulative_Live_Expected, 2), nth(`Expected Skins`, 2)) else NA,
      Score_2 = if(n() > 1) nth(Game_Score, 2) else NA_character_,
      Status = first(Game_Status),
      game_time_ct = first(game_time_ct),
      .groups = 'drop'
    ) %>%
    mutate(
      # Convert ET times in Status to CT for display
      Status_CT = case_when(
        # Check if Status contains ET time pattern (e.g., "7:00 PM ET")
        str_detect(Status, "\\d{1,2}:\\d{2}\\s*[AP]M\\s+ET") ~ {
          # Extract the time string
          time_str <- str_extract(Status, "\\d{1,2}:\\d{2}\\s*[AP]M")
          # Parse as ET time for today
          et_time <- parse_date_time(paste(Sys.Date(), time_str), 
                                     orders = "ymd I:M p", 
                                     tz = "America/New_York")
          # Convert to CT
          ct_time <- with_tz(et_time, tzone = "America/Chicago")
          # Format as time string with CT
          paste(format(ct_time, "%I:%M %p CT"))
        },
        TRUE ~ Status
      ),
      # Create sort order for status
      status_order = case_when(
        Status == "Final" ~ 1,
        str_detect(Status, "Q4") ~ 2,
        str_detect(Status, "Q3") ~ 3,
        str_detect(Status, "Half") ~ 4,
        str_detect(Status, "Q2") ~ 5,
        str_detect(Status, "Q1") ~ 6,
        str_detect(Status, "OT") ~ 2,  # Group OT with Q4
        TRUE ~ 7  # Not Started and other (including upcoming games with times)
      ),
      # For upcoming games (status_order 7), use game time for sorting (soonest first)
      time_order = if_else(
        status_order == 7 & !is.na(game_time_ct), 
        as.numeric(game_time_ct), 
        as.numeric(Sys.time())
      )
    ) %>%
    arrange(status_order, time_order, game_id) %>%
    mutate(
      # Format player names with color highlighting
      Player_1_Display = case_when(
        Status == "Final" & !is.na(Won_Skin_1) & Won_Skin_1 ~ 
          cell_spec(Player_1, background = "#90EE90", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Status == "Final" & !is.na(Won_Skin_1) & !Won_Skin_1 ~ 
          cell_spec(Player_1, background = "#FFB6C6", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player_1
      ),
      Player_2_Display = case_when(
        is.na(Player_2) ~ "",
        Status == "Final" & !is.na(Won_Skin_2) & Won_Skin_2 == TRUE ~ 
          cell_spec(Player_2, background = "#90EE90", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Status == "Final" & !is.na(Won_Skin_2) & Won_Skin_2 == FALSE ~ 
          cell_spec(Player_2, background = "#FFB6C6", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player_2
      ),
      # Add checkmarks for Won_Skin status
      Won_1 = case_when(
        Status != "Final" ~ "",
        is.na(Won_Skin_1) ~ "",
        Won_Skin_1 ~ "✓ Yes",
        TRUE ~ "✗ No"
      ),
      Won_2 = case_when(
        Status != "Final" ~ "",
        is.na(Player_2) ~ "",
        is.na(Won_Skin_2) ~ "",
        Won_Skin_2 ~ "✓ Yes",
        TRUE ~ "✗ No"
      ),
      # Format Live Probabilities - now should always have values
      Live_Prob_1_Display = if_else(is.na(Live_Skin_Prob_1), "", paste0(sprintf("%.0f", Live_Skin_Prob_1 * 100), "%")),
      Live_Prob_2_Display = if_else(is.na(Live_Skin_Prob_2), "", paste0(sprintf("%.0f", Live_Skin_Prob_2 * 100), "%")),
      # FIXED: Format combined score (use first team's score which is in Team1-Team2 format)
      # Only show if not empty
      Combined_Score = if_else(is.na(Score_1) | Score_1 == "", "", Score_1),
      # Create vs. display
      VS = if_else(is.na(Player_2), "", "vs."),
      Team_2_Display = if_else(is.na(Team_2), "", Team_2),
      Pick_2_Display = if_else(is.na(Pick_2), "", Pick_2)
    ) %>%
    # Select final columns
    select(
      Player = Player_1_Display,
      Team = Team_1,
      Pick = Pick_1,
      `Won Skin` = Won_1,
      `Live Skin Prob` = Live_Prob_1_Display, 
      VS,
      `Player 2` = Player_2_Display,
      `Team 2` = Team_2_Display,
      `Pick 2` = Pick_2_Display,
      `Won Skin 2` = Won_2,
      `Live Skin Prob 2` = Live_Prob_2_Display, 
      Status = Status_CT,
      Score = Combined_Score
    )
  
  # Create the table with HTML formatting enabled
  knitr::kable(
    matchup_table,
    align = 'c',
    caption = "Head-to-Head Matchups",
    escape = FALSE,
    format = "html"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
  
} else {
  cat("No games scheduled for today.")
}
```
