---
title: "Today's Skins"
format:
  html:
    self-contained: true
    theme: darkly
    grid:
      body-width: 1200px
    css: |
      table {
        width: auto !important;
        margin-left: auto;
        margin-right: auto;
      }
---

```{r setup}
#| echo: false
#| message: false
#| warning: false
# Load all required packages for the whole document
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rvest, httr, dplyr, tidyr, stringr, lubridate, tibble, knitr, kableExtra, readr, ggplot2)

# Create history directory - use relative path that works in both local and GitHub Actions
history_dir <- "skins_history"
if (!dir.exists(history_dir)) {
  dir.create(history_dir, recursive = TRUE)
}
```

```{r timestamp}
#| echo: false
#| results: 'asis'
ts <- format(Sys.time(), "%A, %B %d, %Y at %I:%M %p %Z", tz = "America/Chicago")
cat(paste0("<p style='font-size:14px; color:#999;'><strong>Last updated:</strong> ", ts, "</p>"))
```

```{r expected_skins_data}
#| echo: false
#| message: false
#| warning: false
# This chunk must run first (invisibly) to create 'todays_picks'
# for the results tables that now appear at the top.

# --- Part 0: Define Time and Data Source ---

# CRITICAL: Get current time in multiple formats for debugging
system_time <- Sys.time()
system_tz <- Sys.timezone()
current_time_ct <- now(tzone = "America/Chicago")
current_hour_ct <- hour(current_time_ct)

# Store for diagnostics
time_debug_info <- list(
  system_time = system_time,
  system_timezone = system_tz,
  chicago_time = current_time_ct,
  chicago_hour = current_hour_ct
)

# Define the "skins date" based on the 2 AM cutoff.
# A "day" runs from 2:00 AM to 1:59 AM the next morning.
if (current_hour_ct < 2) {
  # If it's 1 AM, it's still "yesterday's" skins date
  skins_date <- as_date(current_time_ct) - days(1)
} else {
  # If it's 2 AM or later, it's "today's" skins date
  skins_date <- as_date(current_time_ct)
}

# Use skins_date as the definitive date for this run
today_ct <- skins_date 
current_year <- year(today_ct)

# Define blackout window: 11 PM (23:00) to 1:59 AM
use_csv_for_sportsline <- current_hour_ct >= 23 | current_hour_ct < 2

# Define draft_data (needs to be available for both branches)
draft_data <- tribble(
  ~Team, ~Matchup_Key, ~abbr, ~skins_pick, ~player,
  "Utah Jazz", "Jazz|Utah", "UTA", "L", "Eristeo",
  "Oklahoma City Thunder", "Thunder|Oklahoma", "OKC", "W", "Matt",
  "Washington Wizards", "Wizards|Washington", "WAS", "L", "Brian",
  "Brooklyn Nets", "Nets|Brooklyn", "BKN", "L", "Adam",
  "Cleveland Cavaliers", "Cavaliers|Cleveland", "CLE", "W", "Thomas",
  "Charlotte Hornets", "Hornets|Charlotte", "CHA", "L", "Brian",
  "Denver Nuggets", "Nuggets|Denver", "DEN", "W", "Thomas",
  "New York Knicks", "Knicks|New York", "NYK", "W", "Adam",
  "Houston Rockets", "Rockets|Houston", "HOU", "W", "Kenneth",
  "Phoenix Suns", "Suns|Phoenix", "PHX", "L", "Eristeo",
  "New Orleans Pelicans", "Pelicans|New Orleans", "NOP", "L", "Matt",
  "Orlando Magic", "Magic|Orlando", "ORL", "W", "Kenneth",
  "Chicago Bulls", "Bulls|Chicago", "CHI", "L", "Thomas",
  "Los Angeles Clippers", "Clippers|LA Clippers", "LAC", "W", "Eristeo",
  "Minnesota Timberwolves", "Timberwolves|Minnesota", "MIN", "W", "Matt",
  "Portland Trail Blazers", "Trail Blazers|Portland", "POR", "L", "Kenneth",
  "Atlanta Hawks", "Hawks|Atlanta", "ATL", "W", "Adam",
  "Los Angeles Lakers", "Lakers|LA Lakers", "LAL", "W", "Adam",
  "Golden State Warriors", "Warriors|Golden State", "GSW", "W", "Kenneth",
  "Sacramento Kings", "Kings|Sacramento", "SAC", "L", "Thomas",
  "Detroit Pistons", "Pistons|Detroit", "DET", "W", "Brian",
  "Indiana Pacers", "Pacers|Indiana", "IND", "L", "Eristeo",
  "Miami Heat", "Heat|Miami", "MIA", "L", "Matt",
  "Philadelphia 76ers", "76ers|Philadelphia", "PHI", "W", "Matt",
  "Toronto Raptors", "Raptors|Toronto", "TOR", "L", "Brian",
  "Milwaukee Bucks", "Bucks|Milwaukee", "MIL", "W", "Brian",
  "San Antonio Spurs", "Spurs|San Antonio", "SAS", "W", "Eristeo",
  "Memphis Grizzlies", "Grizzlies|Memphis", "MEM", "W", "Kenneth",
  "Boston Celtics", "Celtics|Boston", "BOS", "W", "Adam",
  "Dallas Mavericks", "Mavericks|Dallas", "DAL", "W", "Thomas"
)

# --- Part 1: Get Data (Conditional) ---
csv_was_used <- FALSE
csv_file_used <- NA_character_

if (use_csv_for_sportsline) {
  file_path <- file.path(history_dir, paste0(skins_date, ".csv"))
  
  if (file.exists(file_path)) {
    csv_data <- read_csv(file_path, show_col_types = FALSE)
    
    if ("game_id" %in% colnames(csv_data)) {
      todays_picks <- csv_data %>%
        mutate(
          "Expected Skins" = Expected_Skins,
          Moneyline = NA_real_,
          "Implied Prob" = NA_real_,
          # CRITICAL: Always reset Live_Expected_Skins to NA - never trust CSV values
          # We will recalculate from fresh Gambletron scrape
          Live_Expected_Skins = NA_real_
        ) %>%
        select(Date, Team, Pick, "Expected Skins", Player, Moneyline, "Implied Prob", Abbr, game_id, Won_Game, Actual_Skins, Skins_Luck, Live_Expected_Skins) %>%
        arrange(desc(`Expected Skins`))
      
      csv_was_used <- TRUE
      csv_file_used <- file_path
        
    } else {
      use_csv_for_sportsline <- FALSE
    }
    
  } else {
    use_csv_for_sportsline <- FALSE
  }
}

if (!use_csv_for_sportsline) {
  # --- Part 1.1: Scrape Expected Odds ---
  url <- paste0("https://www.sportsline.com/nba/odds/money-line/",
                "?t=", format(Sys.time(), "%Y%m%d%H%M%S"))
  googlebot_ua <- "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html"
  page_session <- rvest::session(url, httr::user_agent(googlebot_ua))
  html_content <- rvest::read_html(page_session)
  game_data_raw <- html_content %>% html_element("table") %>% html_table()
  
  # Extract correct columns and clean team names
  game_data <- data.frame(
    Matchup_raw = game_data_raw[[1]],
    consensus = game_data_raw[[3]],
    stringsAsFactors = FALSE
  ) %>%
    mutate(
      # Remove the record (e.g., "2-1") from team names
      Matchup = str_remove(Matchup_raw, "\\d+-\\d+$")
    )

  # --- Part 1.2: Calculate Expected Skins ---
  convert_odds_to_prob <- function(odds) {
    prob <- case_when(
      odds < 0 ~ abs(odds) / (abs(odds) + 100),
      odds > 0 ~ 100 / (odds + 100),
      TRUE ~ NA_real_
    )
    return(prob)
  }
  
  # FIXED: Use word boundaries to prevent "Hornets" from matching "Nets"
  match_team <- function(matchup_str, draft_data) {
    matchup_upper <- str_to_upper(matchup_str)
    for (i in 1:nrow(draft_data)) {
      keys <- str_split(draft_data$Matchup_Key[i], "\\|")[[1]]
      keys_upper <- str_to_upper(keys)
      
      # Check if any of the keys match (with word boundaries)
      for (key in keys_upper) {
        pattern <- paste0("\\b", key, "\\b")
        if (str_detect(matchup_upper, regex(pattern))) {
          return(draft_data$Matchup_Key[i])
        }
      }
    }
    return(NA_character_)
  }
  
  # Parse based on actual structure
  todays_picks <- game_data %>%
    filter(!is.na(Matchup) & Matchup != "") %>%
    mutate(
      row_id = row_number(),
      game_time_str = str_extract(Matchup_raw, 
        "(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+\\d+,\\s+\\d+:\\d+\\s*[AP]M\\s+UTC")
    ) %>%
    # Fill UP because date rows come AFTER team rows
    fill(game_time_str, .direction = "up") %>%
    # Filter out the "Expert Picks" and "Advanced Insights" rows
    filter(!str_detect(Matchup, "Expert Picks|Advanced Insights")) %>%
    # Only keep rows with actual odds (contains +/- numbers)
    filter(str_detect(consensus, "[+-]\\d+")) %>%
    mutate(
      Matchup_Key = vapply(Matchup, match_team, draft_data = draft_data, FUN.VALUE = character(1)),
      game_time_str_with_year = paste(game_time_str, current_year),
      game_time_utc = parse_date_time(
        str_remove(game_time_str_with_year, "\\s+UTC"),
        orders = c("b d, I:M p Y"),
        tz = "UTC"
      ),
      game_time_ct = with_tz(game_time_utc, tzone = "America/Chicago"),
      game_date_ct = as_date(game_time_ct),
      # Create game_id: every 2 consecutive rows are a game
      game_id = paste0(game_date_ct, "_", ceiling(row_number() / 2))
    ) %>%
    # *** THIS IS THE KEY FILTER ***
    # It now filters for games matching the "skins_date" (which is today_ct)
    filter(game_date_ct == today_ct, !is.na(Matchup_Key)) %>%
    mutate(
      # Extract odds from format like "-175Open: -189"
      moneyline = as.numeric(str_extract(consensus, "^[+-]?\\d+")),
      opening_odds = as.numeric(str_extract(consensus, "(?<=Open: )[+-]?\\d+"))
    ) %>%
    # Remove duplicates - keep one row per team per game
    distinct(Matchup_Key, game_id, .keep_all = TRUE) %>%
    mutate(implied_prob = convert_odds_to_prob(moneyline)) %>%
    group_by(game_id) %>%
    mutate(
      total_prob_in_game = sum(implied_prob, na.rm = TRUE),
      prob_no_vig = implied_prob / total_prob_in_game
    ) %>%
    ungroup() %>%
    left_join(draft_data, by = "Matchup_Key") %>%
    filter(!is.na(Team)) %>%
    mutate(
      expected_skins = if_else(skins_pick == "W", prob_no_vig, 1 - prob_no_vig),
      Date = today_ct,
      Won_Game = NA,
      Actual_Skins = NA_real_,
      Skins_Luck = NA_real_,
      Live_Expected_Skins = NA_real_
    ) %>%
    select(Date, Team, Pick = skins_pick, "Expected Skins" = expected_skins,
           Player = player, Moneyline = moneyline, "Implied Prob" = prob_no_vig,
           Abbr = abbr, game_id, Won_Game, Actual_Skins, Skins_Luck, Live_Expected_Skins) %>%
    arrange(desc(`Expected Skins`))
}

# --- Part 2: Handle Draft Data Mismatch ---
# (This runs for both CSV and Scrape methods)
if (nrow(todays_picks) > 0) {
  teams_in_picks <- unique(todays_picks$Team)
  teams_in_draft <- unique(draft_data$Team)
  
  # Teams that are in picks but not in draft (indicates a mismatch in draft_data)
  unmatched_teams_in_picks <- setdiff(teams_in_picks, teams_in_draft)
  if (length(unmatched_teams_in_picks) > 0) {
    cat("WARNING: Teams in scraped data but not in draft_data:", 
        paste(unmatched_teams_in_picks, collapse = ", "), "\n")
  }
}
```

```{r scrape_live_data}
#| echo: false
#| message: false
#| warning: false

# This chunk scrapes live win probabilities from gambletron
# and joins them with our 'todays_picks' data.

# Initialize diagnostic data frame
gambletron_diagnostics <- data.frame()

# Always scrape live data regardless of blackout window
# --- Define URLs ---
url_live <- "https://www.gambletron2000.com/live?sport=nba&team="
url_inactive <- "https://www.gambletron2000.com/inactive?sport=nba&s=start_time&team="

# --- 1. Scrape "Live!" Games ---
response_live <- GET(url_live, user_agent("Mozilla/5.0"))
webpage_live <- read_html(response_live)

live_nodes <- webpage_live %>% html_elements("li.event-summary")

live_games <- live_nodes %>%
  lapply(function(node) {
    teams_text <- node %>% 
      html_element("span.team") %>% 
      html_text2() %>% 
      trimws()
    
    teams <- strsplit(teams_text, "\n")[[1]]
    
    probs <- node %>% 
      html_elements("span.pull-right") %>% 
      html_text() %>% 
      trimws()
    
    data.frame(
      status = "Live",
      team_1 = trimws(teams[1]),
      team_2 = trimws(teams[2]),
      team_1_prob = probs[1],
      team_2_prob = probs[2],
      game_date = NA_character_,
      sport = trimws(html_element(node, ".sport .sport-emoji") %>% html_attr("alt"))
    )
  }) %>%
  bind_rows()

# --- 2. Scrape "Inactive" Games (Starting Later & Finished) ---
response_inactive <- GET(url_inactive, user_agent("Mozilla/5.0"))
webpage_inactive <- read_html(response_inactive)

# --- 2a. Parse "Starting Later" ---
starting_later_nodes <- webpage_inactive %>% 
  html_elements("#later-container a.event-link")

starting_later_games <- starting_later_nodes %>%
  lapply(function(node) {
    data.frame(
      status = "Starting Later",
      team_1 = trimws(html_element(node, ".team .away") %>% html_text()),
      team_2 = trimws(html_element(node, ".team .home") %>% html_text()),
      team_1_prob = trimws(html_element(node, ".prob .away") %>% html_text()),
      team_2_prob = trimws(html_element(node, ".prob .home") %>% html_text()),
      game_date = trimws(html_element(node, ".event-time .gt-timestamp") %>% html_text()),
      sport = trimws(html_element(node, ".sport .sport-emoji") %>% html_attr("alt"))
    )
  }) %>%
  bind_rows()

# --- 2b. Parse "Finished" ---
finished_nodes <- webpage_inactive %>% 
  html_elements("#earlier-container a.event-link")

finished_games <- finished_nodes %>%
  lapply(function(node) {
    team_1_is_winner <- !is.na(html_element(node, ".team .away.winner"))
    team_2_is_winner <- !is.na(html_element(node, ".team .home.winner"))
    
    data.frame(
      status = "Finished",
      team_1 = trimws(html_element(node, ".team .away") %>% html_text()),
      team_2 = trimws(html_element(node, ".team .home") %>% html_text()),
      team_1_prob = if_else(team_1_is_winner, "100%", if_else(team_2_is_winner, "0%", NA_character_)),
      team_2_prob = if_else(team_2_is_winner, "100%", if_else(team_1_is_winner, "0%", NA_character_)),
      game_date = trimws(html_element(node, ".event-time .gt-timestamp") %>% html_text()),
      sport = trimws(html_element(node, ".sport .sport-emoji") %>% html_attr("alt"))
    )
  }) %>%
  bind_rows()

# --- 3. Combine all data ---
all_games <- bind_rows(live_games, starting_later_games, finished_games)

# --- 4. Define "today" ---
m <- sub("^0", "", format(Sys.Date(), "%m")) 
d <- sub("^0", "", format(Sys.Date(), "%d")) 
today_date <- paste(m, d, sep="/")

# --- 5. Filter for NBA and Today ---
# IMPORTANT: For "Live" games, game_date is NA, so we include those
# For "Starting Later", we filter by today's date
nba_today <- all_games %>%
  filter(
    sport == "NBA",
    (status == "Live" | status == "Finished" | game_date == today_date)
  )

# Store counts for debugging
game_counts_debug <- list(
  total_games = nrow(all_games),
  nba_games = sum(all_games$sport == "NBA", na.rm = TRUE),
  live_games = sum(all_games$status == "Live" & all_games$sport == "NBA", na.rm = TRUE),
  starting_later = sum(all_games$status == "Starting Later" & all_games$sport == "NBA", na.rm = TRUE),
  finished_games = sum(all_games$status == "Finished" & all_games$sport == "NBA", na.rm = TRUE),
  nba_today_count = nrow(nba_today),
  today_date_filter = today_date
)

# Store raw scraped data for diagnostics
gambletron_diagnostics <- nba_today %>%
  mutate(scrape_timestamp = Sys.time())

# --- 6. Process and Join Scraped Data ---
live_data_standardized <- data.frame()  # Initialize for diagnostics
live_data_for_diagnostics <- data.frame()  # Initialize for diagnostics
live_data_final <- data.frame()  # Initialize for diagnostics

if (nrow(nba_today) > 0 && nrow(todays_picks) > 0) {
  # Convert probabilities from "XX%" string to numeric
  convert_prob_to_num <- function(prob_str) {
    as.numeric(str_remove(prob_str, "%")) / 100.0
  }
  
  # IMPROVED: Create game-pair data first to ensure probabilities are complementary
  nba_today_processed <- nba_today %>%
    mutate(
      prob_1_num = convert_prob_to_num(team_1_prob),
      prob_2_num = convert_prob_to_num(team_2_prob),
      # Validate that probabilities sum to approximately 1.0
      prob_sum = prob_1_num + prob_2_num,
      prob_valid = abs(prob_sum - 1.0) < 0.05,  # Allow 5% tolerance
      # Create a unique game identifier
      game_pair_id = paste0("gp_", row_number())
    )
  
  # Reshape data to one row per team, keeping game_pair_id
  live_data_team1 <- nba_today_processed %>%
    select(Team = team_1, live_win_prob = prob_1_num, game_pair_id, prob_valid, status)
  
  live_data_team2 <- nba_today_processed %>%
    select(Team = team_2, live_win_prob = prob_2_num, game_pair_id, prob_valid, status)
    
  live_data_combined <- bind_rows(live_data_team1, live_data_team2) %>%
    mutate(Team = trimws(Team))
  
  # Standardize team names
  live_data_standardized <- live_data_combined %>%
    mutate(
      Team_Original = Team,  # Keep original for diagnostics
      Team = case_when(
        # Portland Trail Blazers
        str_detect(Team, regex("\\bBlazers?\\b", ignore_case = TRUE)) ~ "Portland Trail Blazers",
        str_detect(Team, regex("\\bPortland\\b", ignore_case = TRUE)) ~ "Portland Trail Blazers",
        str_detect(Team, regex("\\bTrail\\s*Blazers?\\b", ignore_case = TRUE)) ~ "Portland Trail Blazers",
        
        # Philadelphia 76ers
        str_detect(Team, regex("\\b76ers?\\b", ignore_case = TRUE)) ~ "Philadelphia 76ers",
        str_detect(Team, regex("\\bPhiladelphia\\b", ignore_case = TRUE)) ~ "Philadelphia 76ers",
        str_detect(Team, regex("\\bPhilly\\b", ignore_case = TRUE)) ~ "Philadelphia 76ers",
        str_detect(Team, regex("\\bSixers?\\b", ignore_case = TRUE)) ~ "Philadelphia 76ers",
        
        # Detroit Pistons
        str_detect(Team, regex("\\bPistons?\\b", ignore_case = TRUE)) ~ "Detroit Pistons",
        str_detect(Team, regex("\\bDetroit\\b", ignore_case = TRUE)) ~ "Detroit Pistons",
        
        # Miami Heat
        str_detect(Team, regex("\\bHeat\\b", ignore_case = TRUE)) ~ "Miami Heat",
        str_detect(Team, regex("\\bMiami\\b", ignore_case = TRUE)) ~ "Miami Heat",
        
        # Boston Celtics
        str_detect(Team, regex("\\bCeltics?\\b", ignore_case = TRUE)) ~ "Boston Celtics",
        str_detect(Team, regex("\\bBoston\\b", ignore_case = TRUE)) ~ "Boston Celtics",
        
        # Brooklyn Nets (MUST come before checking for just "Nets")
        str_detect(Team, regex("\\bBrooklyn\\b", ignore_case = TRUE)) ~ "Brooklyn Nets",
        str_detect(Team, regex("\\bBrooklyn\\s+Nets?\\b", ignore_case = TRUE)) ~ "Brooklyn Nets",
        str_detect(Team, regex("\\bNets?\\b", ignore_case = TRUE)) & !str_detect(Team, regex("\\bHornets?\\b", ignore_case = TRUE)) ~ "Brooklyn Nets",
        
        # New York Knicks
        str_detect(Team, regex("\\bKnicks?\\b", ignore_case = TRUE)) ~ "New York Knicks",
        str_detect(Team, regex("\\bNew\\s+York\\b", ignore_case = TRUE)) & !str_detect(Team, regex("\\bPelicans?\\b", ignore_case = TRUE)) ~ "New York Knicks",
        str_detect(Team, regex("\\bNY\\b(?!\\s*Pelicans?)", ignore_case = TRUE)) ~ "New York Knicks",
        
        # Toronto Raptors
        str_detect(Team, regex("\\bRaptors?\\b", ignore_case = TRUE)) ~ "Toronto Raptors",
        str_detect(Team, regex("\\bToronto\\b", ignore_case = TRUE)) ~ "Toronto Raptors",
        
        # Chicago Bulls
        str_detect(Team, regex("\\bBulls?\\b", ignore_case = TRUE)) ~ "Chicago Bulls",
        str_detect(Team, regex("\\bChicago\\b", ignore_case = TRUE)) ~ "Chicago Bulls",
        
        # Cleveland Cavaliers
        str_detect(Team, regex("\\bCavaliers?\\b", ignore_case = TRUE)) ~ "Cleveland Cavaliers",
        str_detect(Team, regex("\\bCleveland\\b", ignore_case = TRUE)) ~ "Cleveland Cavaliers",
        str_detect(Team, regex("\\bCavs?\\b", ignore_case = TRUE)) ~ "Cleveland Cavaliers",
        
        # Indiana Pacers
        str_detect(Team, regex("\\bPacers?\\b", ignore_case = TRUE)) ~ "Indiana Pacers",
        str_detect(Team, regex("\\bIndiana\\b", ignore_case = TRUE)) ~ "Indiana Pacers",
        
        # Milwaukee Bucks
        str_detect(Team, regex("\\bBucks?\\b", ignore_case = TRUE)) ~ "Milwaukee Bucks",
        str_detect(Team, regex("\\bMilwaukee\\b", ignore_case = TRUE)) ~ "Milwaukee Bucks",
        
        # Atlanta Hawks
        str_detect(Team, regex("\\bHawks?\\b", ignore_case = TRUE)) ~ "Atlanta Hawks",
        str_detect(Team, regex("\\bAtlanta\\b", ignore_case = TRUE)) ~ "Atlanta Hawks",
        
        # Charlotte Hornets
        str_detect(Team, regex("\\bHornets?\\b", ignore_case = TRUE)) ~ "Charlotte Hornets",
        str_detect(Team, regex("\\bCharlotte\\b", ignore_case = TRUE)) ~ "Charlotte Hornets",
        
        # Orlando Magic
        str_detect(Team, regex("\\bMagic\\b", ignore_case = TRUE)) ~ "Orlando Magic",
        str_detect(Team, regex("\\bOrlando\\b", ignore_case = TRUE)) ~ "Orlando Magic",
        
        # Washington Wizards
        str_detect(Team, regex("\\bWizards?\\b", ignore_case = TRUE)) ~ "Washington Wizards",
        str_detect(Team, regex("\\bWashington\\b", ignore_case = TRUE)) ~ "Washington Wizards",
        
        # Denver Nuggets
        str_detect(Team, regex("\\bNuggets?\\b", ignore_case = TRUE)) ~ "Denver Nuggets",
        str_detect(Team, regex("\\bDenver\\b", ignore_case = TRUE)) ~ "Denver Nuggets",
        
        # Minnesota Timberwolves
        str_detect(Team, regex("\\bTimberwolves?\\b", ignore_case = TRUE)) ~ "Minnesota Timberwolves",
        str_detect(Team, regex("\\bMinnesota\\b", ignore_case = TRUE)) ~ "Minnesota Timberwolves",
        str_detect(Team, regex("\\bT-?Wolves?\\b", ignore_case = TRUE)) ~ "Minnesota Timberwolves",
        
        # Oklahoma City Thunder
        str_detect(Team, regex("\\bThunder\\b", ignore_case = TRUE)) ~ "Oklahoma City Thunder",
        str_detect(Team, regex("\\bOklahoma\\s*City\\b", ignore_case = TRUE)) ~ "Oklahoma City Thunder",
        str_detect(Team, regex("\\bOKC\\b", ignore_case = TRUE)) ~ "Oklahoma City Thunder",
        
        # Utah Jazz
        str_detect(Team, regex("\\bJazz\\b", ignore_case = TRUE)) ~ "Utah Jazz",
        str_detect(Team, regex("\\bUtah\\b", ignore_case = TRUE)) ~ "Utah Jazz",
        
        # Golden State Warriors
        str_detect(Team, regex("\\bWarriors?\\b", ignore_case = TRUE)) ~ "Golden State Warriors",
        str_detect(Team, regex("\\bGolden\\s*State\\b", ignore_case = TRUE)) ~ "Golden State Warriors",
        str_detect(Team, regex("\\bGS\\b(?!W)", ignore_case = TRUE)) ~ "Golden State Warriors",
        
        # Los Angeles Clippers
        str_detect(Team, regex("\\bClippers?\\b", ignore_case = TRUE)) ~ "Los Angeles Clippers",
        str_detect(Team, regex("\\bLA\\s*Clippers?\\b", ignore_case = TRUE)) ~ "Los Angeles Clippers",
        str_detect(Team, regex("\\bL\\.?A\\.?\\s*Clippers?\\b", ignore_case = TRUE)) ~ "Los Angeles Clippers",
        
        # Los Angeles Lakers
        str_detect(Team, regex("\\bLakers?\\b", ignore_case = TRUE)) ~ "Los Angeles Lakers",
        str_detect(Team, regex("\\bLA\\s*Lakers?\\b", ignore_case = TRUE)) ~ "Los Angeles Lakers",
        str_detect(Team, regex("\\bL\\.?A\\.?\\s*Lakers?\\b", ignore_case = TRUE)) ~ "Los Angeles Lakers",
        
        # Phoenix Suns
        str_detect(Team, regex("\\bSuns?\\b", ignore_case = TRUE)) ~ "Phoenix Suns",
        str_detect(Team, regex("\\bPhoenix\\b", ignore_case = TRUE)) ~ "Phoenix Suns",
        
        # Sacramento Kings
        str_detect(Team, regex("\\bKings?\\b", ignore_case = TRUE)) ~ "Sacramento Kings",
        str_detect(Team, regex("\\bSacramento\\b", ignore_case = TRUE)) ~ "Sacramento Kings",
        
        # Dallas Mavericks
        str_detect(Team, regex("\\bMavericks?\\b", ignore_case = TRUE)) ~ "Dallas Mavericks",
        str_detect(Team, regex("\\bDallas\\b", ignore_case = TRUE)) ~ "Dallas Mavericks",
        str_detect(Team, regex("\\bMavs?\\b", ignore_case = TRUE)) ~ "Dallas Mavericks",
        
        # Houston Rockets
        str_detect(Team, regex("\\bRockets?\\b", ignore_case = TRUE)) ~ "Houston Rockets",
        str_detect(Team, regex("\\bHouston\\b", ignore_case = TRUE)) ~ "Houston Rockets",
        
        # Memphis Grizzlies
        str_detect(Team, regex("\\bGrizzlies?\\b", ignore_case = TRUE)) ~ "Memphis Grizzlies",
        str_detect(Team, regex("\\bMemphis\\b", ignore_case = TRUE)) ~ "Memphis Grizzlies",
        
        # New Orleans Pelicans
        str_detect(Team, regex("\\bPelicans?\\b", ignore_case = TRUE)) ~ "New Orleans Pelicans",
        str_detect(Team, regex("\\bNew\\s*Orleans\\b", ignore_case = TRUE)) ~ "New Orleans Pelicans",
        str_detect(Team, regex("\\bNO\\b(?!\\s*Lakers?)", ignore_case = TRUE)) ~ "New Orleans Pelicans",
        
        # San Antonio Spurs
        str_detect(Team, regex("\\bSpurs?\\b", ignore_case = TRUE)) ~ "San Antonio Spurs",
        str_detect(Team, regex("\\bSan\\s*Antonio\\b", ignore_case = TRUE)) ~ "San Antonio Spurs",
        
        TRUE ~ Team
      )
    )
  
  # CRITICAL FIX: Ensure complementary probabilities within each game
  # For each game_pair_id, verify both teams have complementary probabilities
  live_data_final <- live_data_standardized %>%
    group_by(game_pair_id) %>%
    mutate(
      # If probabilities don't sum to 1, normalize them
      needs_normalization = !first(prob_valid),
      normalized_prob = if_else(needs_normalization, 
                                 live_win_prob / sum(live_win_prob, na.rm = TRUE),
                                 live_win_prob)
    ) %>%
    ungroup() %>%
    select(Team, live_win_prob = normalized_prob, game_pair_id, status, Team_Original) %>%
    # IMPROVED: Handle duplicates by keeping the most relevant entry
    # Priority: Live > Starting Later > Finished
    # Within same status, keep first occurrence
    arrange(
      Team,
      case_when(
        status == "Live" ~ 1,
        status == "Starting Later" ~ 2,
        status == "Finished" ~ 3,
        TRUE ~ 4
      )
    ) %>%
    group_by(Team) %>%
    slice(1) %>%  # Keep only first occurrence per team after sorting
    ungroup() %>%
    select(Team, live_win_prob)
  
  # Store for diagnostics BEFORE removing Team_Original
  live_data_for_diagnostics <- live_data_standardized %>%
    select(Team_Original, Team, live_win_prob, game_pair_id, status)

  # Join with todays_picks and calculate Live Expected Skins
  todays_picks <- todays_picks %>%
    left_join(live_data_final, by = "Team") %>%
    mutate(
      Live_Expected_Skins = case_when(
        is.na(live_win_prob) ~ Live_Expected_Skins,
        Pick == "W" ~ live_win_prob,
        Pick == "L" ~ 1 - live_win_prob,
        TRUE ~ Live_Expected_Skins
      )
    ) %>%
    select(-live_win_prob)
  
  # CRITICAL FIX: Fill in missing Live_Expected_Skins using complementary probabilities
  # If one team in a game has Live_Expected_Skins but the other doesn't, calculate from complement
  todays_picks <- todays_picks %>%
    group_by(game_id) %>%
    mutate(
      # Count how many teams in this game have live data
      teams_with_live = sum(!is.na(Live_Expected_Skins)),
      # If exactly one team has live data, we can fill in the other
      can_fill_from_opponent = teams_with_live == 1 & n() == 2
    ) %>%
    ungroup()
  
  # For games where we can fill from opponent
  if (any(todays_picks$can_fill_from_opponent, na.rm = TRUE)) {
    todays_picks <- todays_picks %>%
      group_by(game_id) %>%
      mutate(
        # Get the non-NA Live_Expected_Skins value in this game (if any)
        opponent_live_skins = first(na.omit(Live_Expected_Skins)),
        # Fill NA values with complementary probability
        Live_Expected_Skins = if_else(
          can_fill_from_opponent & is.na(Live_Expected_Skins),
          opponent_live_skins,  # Use same value since they're complementary bets
          Live_Expected_Skins
        )
      ) %>%
      ungroup() %>%
      select(-opponent_live_skins)
  }
  
  # Clean up helper columns
  todays_picks <- todays_picks %>%
    select(-teams_with_live, -can_fill_from_opponent)
  
  # ENHANCED FIX: For same player with opposite picks in same game, ensure equal expected skins
  # This handles the case where Thomas has both Denver (W) and Sacramento (L)
  todays_picks <- todays_picks %>%
    group_by(game_id) %>%
    mutate(
      # If all teams in game have live data, average them to ensure consistency
      all_have_live = all(!is.na(Live_Expected_Skins)) & n() >= 2,
      avg_live_expected = if_else(all_have_live, mean(Live_Expected_Skins, na.rm = TRUE), NA_real_),
      Live_Expected_Skins = if_else(all_have_live & !is.na(avg_live_expected),
                                     avg_live_expected,
                                     Live_Expected_Skins)
    ) %>%
    ungroup() %>%
    select(-all_have_live, -avg_live_expected)
}

# Ensure Live_Expected_Skins column exists even if scraping was skipped
if (!"Live_Expected_Skins" %in% names(todays_picks)) {
  todays_picks <- todays_picks %>%
    mutate(Live_Expected_Skins = NA_real_)
}
```

```{r results_and_luck}
#| echo: false
#| message: false
#| warning: false

# Only process results if we have games today
if (nrow(todays_picks) > 0) {
  
  # Always scrape plaintextsports regardless of blackout window
  # 1. Scrape plaintextsports.com for live game data
  url_scores <- "https://plaintextsports.com/nba/"
  page_scores <- read_html(url_scores)
  
  # Get all text from the body
  all_text <- page_scores %>%
    html_element("body") %>%
    html_text2()
  
  # 2. Extract Game Blocks - Split into lines and get score boxes
  all_lines <- strsplit(all_text, "\n")[[1]]
  score_boxes <- all_lines[grepl("^\\+", all_lines)]
  
  # 3. Parse a single game box
  parse_game_box <- function(box) {
    # Split by "|" character
    parts <- strsplit(box, "\\|")[[1]]
    
    # Extract status, teams, and scores
    status <- str_trim(parts[2])
    
    # Team 1
    team1_line <- str_trim(parts[4])
    team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
    team1_score <- suppressWarnings(as.numeric(str_extract(team1_line, "[0-9]+$")))
    
    # Team 2
    team2_line <- str_trim(parts[6])
    team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
    team2_score <- suppressWarnings(as.numeric(str_extract(team2_line, "[0-9]+$")))
    
    # Determine if final
    is_final <- grepl("Final", status, fixed = TRUE)
    
    # Determine if game is in progress
    is_in_progress <- grepl("Q[1-4]|Half|OT|\\d+:\\d+", status) & !is_final
    
    # Return data frame
    data.frame(
      Team1 = team1_name,
      Team2 = team2_name,
      Score1 = team1_score,
      Score2 = team2_score,
      Status = status,
      Finished = is_final,
      InProgress = is_in_progress,
      stringsAsFactors = FALSE
    )
  }
  
  # 4. Parse all game boxes
  if (length(score_boxes) > 0) {
    all_game_results <- bind_rows(lapply(score_boxes, parse_game_box))
  } else {
    all_game_results <- data.frame()
  }
  
  # 5. Standardize team abbreviations to match draft_data
  team_replacements <- c(
    "^GS$" = "GSW",
    "^NO$" = "NOP",
    "^NY$" = "NYK",
    "^SA$" = "SAS",
    "^WSH$" = "WAS"
  )
  
  # Apply standardization
  if (nrow(all_game_results) > 0) {
    all_game_results <- all_game_results %>%
      mutate(
        Team1 = str_replace_all(Team1, team_replacements),
        Team2 = str_replace_all(Team2, team_replacements)
      )
  }
  
  # 6. Create Won_Game lookup - only for finished games
  final_team_results <- data.frame(Abbr = character(), Won_Game = logical(), stringsAsFactors = FALSE)
  
  if (nrow(all_game_results) > 0) {
    finished_games <- all_game_results %>% filter(Finished == TRUE)
    
    if (nrow(finished_games) > 0) {
      # Team 1 results
      team1_results <- finished_games %>%
        select(Abbr = Team1, PTS = Score1, Opp_PTS = Score2) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      # Team 2 results
      team2_results <- finished_games %>%
        select(Abbr = Team2, PTS = Score2, Opp_PTS = Score1) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      final_team_results <- bind_rows(team1_results, team2_results) %>%
        select(Abbr, Won_Game)
    }
  }
  
  # 6. Create todays_results with actual outcomes
  todays_results <- todays_picks %>%
    left_join(final_team_results, by = "Abbr", suffix = c("", "_new")) %>%
    mutate(
      Won_Game = coalesce(Won_Game_new, Won_Game),
      Actual_Skins = case_when(
        Won_Game == TRUE & Pick == "W" ~ 1,
        Won_Game == FALSE & Pick == "L" ~ 1,
        is.na(Won_Game) ~ NA_real_,
        TRUE ~ 0
      ),
      Skins_Luck = Actual_Skins - `Expected Skins`
    ) %>%
    select(-Won_Game_new)
  
  # 7. Save today's results to file (use underscores for easier CSV handling)
  # This now correctly uses today_ct (which is skins_date) as the filename
  today_file <- file.path(history_dir, paste0(today_ct, ".csv"))
  
  todays_results %>%
    select(
      Date, Player, Team, Abbr, Pick, 
      Expected_Skins = `Expected Skins`, 
      Won_Game, Actual_Skins, Skins_Luck,
      game_id
    ) %>%
    write_csv(today_file)
} else {
  todays_results <- data.frame()
}
```

---

## Final Player Summary (Expected vs. Actual)

```{r final_player_summary}
#| echo: false
#| message: false
#| warning: false

# Print Final Player Summary
if (exists("todays_results") && nrow(todays_results) > 0) {
  
  # Calculate cumulative live expected skins
  todays_results_with_cumulative <- todays_results %>%
    mutate(
      Cumulative_Live_Expected = if_else(!is.na(Won_Game), Actual_Skins, Live_Expected_Skins)
    )
  
  # Identify self zero-sum matchups (same player, both teams in same game)
  self_zero_sum_players <- todays_results_with_cumulative %>%
    group_by(game_id, Player) %>%
    filter(n() >= 2) %>%
    pull(Player) %>%
    unique()
  
  # Calculate Perfect Skins % for each player
  perfect_skins_calc <- todays_results_with_cumulative %>%
    group_by(Player) %>%
    summarise(
      num_games = n(),
      perfect_prob = prod(Cumulative_Live_Expected, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    mutate(
      `Perfect Skins %` = case_when(
        # If player has self zero-sum matchup, 0%
        Player %in% self_zero_sum_players ~ 0,
        # If player has less than 5 games, 0%
        num_games < 5 ~ 0,
        # Otherwise, multiply live expected skins probabilities and convert to %
        TRUE ~ perfect_prob * 100
      )
    ) %>%
    select(Player, `Perfect Skins %`)
  
  final_player_summary <- todays_results_with_cumulative %>%
    group_by(Player) %>%
    summarise(
      `Total Expected Skins` = sum(`Expected Skins`, na.rm = TRUE),
      `Live Expected Skins` = sum(Cumulative_Live_Expected, na.rm = TRUE),
      `Total Actual Skins` = sum(Actual_Skins, na.rm = TRUE),
      `Skins Luck` = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    mutate(
      `Live Skins Luck` = `Live Expected Skins` - `Total Expected Skins`
    ) %>%
    left_join(perfect_skins_calc, by = "Player") %>%
    select(
      Player, 
      `Total Expected Skins`, 
      `Live Expected Skins`,
      `Total Actual Skins`, 
      `Skins Luck`, 
      `Live Skins Luck`,
      `Perfect Skins %`
    ) %>%
    arrange(desc(`Skins Luck`)) %>%
    mutate(
      # Apply color coding to Player column
      Player_Display = case_when(
        `Skins Luck` > 0 ~ 
          cell_spec(Player, background = "#90EE90", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        `Skins Luck` < 0 ~ 
          cell_spec(Player, background = "#FFB6C6", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player
      ),
      # Apply color coding to Live Skins Luck column - exclude values between -0.1 and 0.1
      `Live Skins Luck Display` = case_when(
        `Live Skins Luck` > 0.1 ~ 
          cell_spec(sprintf("%.1f", `Live Skins Luck`), background = "#90EE90", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        `Live Skins Luck` < -0.1 ~ 
          cell_spec(sprintf("%.1f", `Live Skins Luck`), background = "#FFB6C6", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ as.character(sprintf("%.1f", `Live Skins Luck`))
      )
    ) %>%
    select(
      Player = Player_Display,
      `Total Expected Skins`,
      `Live Expected Skins`,
      `Total Actual Skins`,
      `Skins Luck`,
      `Live Skins Luck` = `Live Skins Luck Display`,
      `Perfect Skins %`
    )
  
  # Add TOTAL row
  total_row <- data.frame(
    Player = "TOTAL",
    `Total Expected Skins` = sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE),
    `Live Expected Skins` = sum(todays_results_with_cumulative$Cumulative_Live_Expected, na.rm = TRUE),
    `Total Actual Skins` = sum(todays_results_with_cumulative$Actual_Skins, na.rm = TRUE),
    `Skins Luck` = sum(todays_results_with_cumulative$Skins_Luck, na.rm = TRUE),
    `Live Skins Luck` = sprintf("%.1f", sum(todays_results_with_cumulative$Cumulative_Live_Expected, na.rm = TRUE) - 
                         sum(todays_results_with_cumulative$`Expected Skins`, na.rm = TRUE)),
    `Perfect Skins %` = NA_real_,
    check.names = FALSE,
    stringsAsFactors = FALSE
  )
  
  final_player_summary_with_total <- bind_rows(final_player_summary, total_row)
  
  knitr::kable(
    final_player_summary_with_total,
    digits = 1,
    align = 'c',
    escape = FALSE,
    format = "html"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(c(5, 6, 7), bold = TRUE) %>%
    row_spec(nrow(final_player_summary_with_total), bold = TRUE, background = "#444444")
}
```

---

## Today's Results & Skins Luck

```{r matchup_table}
#| echo: false
#| message: false
#| warning: false

# Create Head-to-Head Matchup Table
if (nrow(todays_picks) > 0) {
  
  # Scrape plaintextsports.com for game results
  url_scores <- "https://plaintextsports.com/nba/"
  page_scores <- read_html(url_scores)
  
  # Get all text
  all_text <- page_scores %>%
    html_element("body") %>%
    html_text2()
  
  # Extract score boxes
  all_lines <- strsplit(all_text, "\n")[[1]]
  score_boxes <- all_lines[grepl("^\\+", all_lines)]
  
  # Parse game boxes
  parse_game_box <- function(box) {
    parts <- strsplit(box, "\\|")[[1]]
    status <- str_trim(parts[2])
    
    team1_line <- str_trim(parts[4])
    team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
    team1_score <- suppressWarnings(as.numeric(str_extract(team1_line, "[0-9]+$")))
    
    team2_line <- str_trim(parts[6])
    team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
    team2_score <- suppressWarnings(as.numeric(str_extract(team2_line, "[0-9]+$")))
    
    is_final <- grepl("Final", status, fixed = TRUE)
    
    # Determine if game is in progress: contains Q1-Q4, Half, OT, or time with a colon
    is_in_progress <- grepl("Q[1-4]|Half|OT|\\d+:\\d+", status) & !is_final
    
    data.frame(
      Team1 = team1_name,
      Team2 = team2_name,
      Score1 = team1_score,
      Score2 = team2_score,
      Status = status,
      Finished = is_final,
      InProgress = is_in_progress,
      stringsAsFactors = FALSE
    )
  }
  
  # Parse all games
  if (length(score_boxes) > 0) {
    matchup_game_results <- bind_rows(lapply(score_boxes, parse_game_box))
  } else {
    matchup_game_results <- data.frame()
  }
  
  # Standardize abbreviations: Map scraped names to draft_data names
  team_replacements <- c(
    "^GS$" = "GSW",
    "^NO$" = "NOP",
    "^NY$" = "NYK",
    "^SA$" = "SAS",
    "^WSH$" = "WAS"
  )
  
  if (nrow(matchup_game_results) > 0) {
    matchup_game_results <- matchup_game_results %>%
      mutate(
        Team1 = str_replace_all(Team1, team_replacements),
        Team2 = str_replace_all(Team2, team_replacements)
      )
  }
  
  # Create Won_Game lookup - only final games
  matchup_won_lookup <- data.frame(Abbr = character(), Won_Game = logical(), stringsAsFactors = FALSE)
  matchup_status_lookup <- data.frame(Abbr = character(), GameStatus = character(), stringsAsFactors = FALSE)
  
  if (nrow(matchup_game_results) > 0) {
    # Won_Game lookup for finished games
    finished_games <- matchup_game_results %>% filter(Finished == TRUE)
    
    if (nrow(finished_games) > 0) {
      team_1 <- finished_games %>%
        select(Abbr = Team1, PTS = Score1, Opp_PTS = Score2) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      team_2 <- finished_games %>%
        select(Abbr = Team2, PTS = Score2, Opp_PTS = Score1) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      matchup_won_lookup <- bind_rows(team_1, team_2) %>%
        select(Abbr, Won_Game)
    }
    
    # Status lookup for all games
    all_games_status <- matchup_game_results %>%
      mutate(
        GameStatus = case_when(
          Finished == TRUE ~ "Final",
          InProgress == TRUE ~ str_remove(Status, "^(WA|WB|WC|WD|EA|EB|EC|ED)\\s+"),
          TRUE ~ "Not Started"
        )
      )
    
    team_1_status <- all_games_status %>%
      select(Abbr = Team1, GameStatus)
    
    team_2_status <- all_games_status %>%
      select(Abbr = Team2, GameStatus)
    
    matchup_status_lookup <- bind_rows(team_1_status, team_2_status) %>%
      distinct()
  }
  
  # Update todays_picks with Won_Game and GameStatus
  todays_picks <- todays_picks %>%
    left_join(matchup_won_lookup, by = "Abbr", suffix = c("", "_new")) %>%
    left_join(matchup_status_lookup, by = "Abbr") %>%
    mutate(
      Won_Game = coalesce(Won_Game_new, Won_Game),
      Won_Skin = case_when(
        Won_Game == TRUE & Pick == "W" ~ TRUE,
        Won_Game == FALSE & Pick == "L" ~ TRUE,
        is.na(Won_Game) ~ NA,
        TRUE ~ FALSE
      ),
      Game_Status = if_else(is.na(GameStatus), "Not Started", GameStatus)
    ) %>%
    select(-Won_Game_new, -GameStatus)
  
  # Build the matchup table - ONE ROW PER GAME
  matchup_prep <- todays_picks %>%
    mutate(
      # IMPROVED: Use first non-NA value for cumulative calculation
      Cumulative_Live_Expected = case_when(
        !is.na(Won_Game) ~ Actual_Skins,
        !is.na(Live_Expected_Skins) ~ Live_Expected_Skins,
        TRUE ~ `Expected Skins`  # Fallback to Expected if Live is also NA
      )
    ) %>%
    arrange(game_id)
  
  # Create one row per game with both players
  matchup_table <- matchup_prep %>%
    group_by(game_id) %>%
    summarise(
      Player_1 = first(Player),
      Team_1 = first(Team),
      Pick_1 = first(Pick),
      Won_Skin_1 = first(Won_Skin),
      # IMPROVED: Get first non-NA live expected skins
      Live_Skin_Prob_1 = coalesce(first(Cumulative_Live_Expected), first(`Expected Skins`)),
      Player_2 = if(n() > 1) nth(Player, 2) else NA_character_,
      Team_2 = if(n() > 1) nth(Team, 2) else NA_character_,
      Pick_2 = if(n() > 1) nth(Pick, 2) else NA_character_,
      Won_Skin_2 = if(n() > 1) nth(Won_Skin, 2) else NA,
      # IMPROVED: Get second non-NA live expected skins
      Live_Skin_Prob_2 = if(n() > 1) coalesce(nth(Cumulative_Live_Expected, 2), nth(`Expected Skins`, 2)) else NA,
      Status = first(Game_Status),
      .groups = 'drop'
    ) %>%
    mutate(
      # Create sort order for status
      status_order = case_when(
        Status == "Final" ~ 1,
        str_detect(Status, "Q4") ~ 2,
        str_detect(Status, "Q3") ~ 3,
        str_detect(Status, "Half") ~ 4,
        str_detect(Status, "Q2") ~ 5,
        str_detect(Status, "Q1") ~ 6,
        str_detect(Status, "OT") ~ 2,  # Group OT with Q4
        TRUE ~ 7  # Not Started and other
      )
    ) %>%
    arrange(status_order, game_id) %>%
    mutate(
      # Format player names with color highlighting
      Player_1_Display = case_when(
        Status == "Final" & !is.na(Won_Skin_1) & Won_Skin_1 ~ 
          cell_spec(Player_1, background = "#90EE90", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Status == "Final" & !is.na(Won_Skin_1) & !Won_Skin_1 ~ 
          cell_spec(Player_1, background = "#FFB6C6", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player_1
      ),
      Player_2_Display = case_when(
        is.na(Player_2) ~ "",
        Status == "Final" & !is.na(Won_Skin_2) & Won_Skin_2 == TRUE ~ 
          cell_spec(Player_2, background = "#90EE90", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Status == "Final" & !is.na(Won_Skin_2) & Won_Skin_2 == FALSE ~ 
          cell_spec(Player_2, background = "#FFB6C6", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player_2
      ),
      # Add checkmarks for Won_Skin status
      Won_1 = case_when(
        Status != "Final" ~ "",
        is.na(Won_Skin_1) ~ "",
        Won_Skin_1 ~ "✓ Yes",
        TRUE ~ "✗ No"
      ),
      Won_2 = case_when(
        Status != "Final" ~ "",
        is.na(Player_2) ~ "",
        is.na(Won_Skin_2) ~ "",
        Won_Skin_2 ~ "✓ Yes",
        TRUE ~ "✗ No"
      ),
      # Format Live Probabilities - now should always have values
      Live_Prob_1_Display = if_else(is.na(Live_Skin_Prob_1), "", paste0(sprintf("%.0f", Live_Skin_Prob_1 * 100), "%")),
      Live_Prob_2_Display = if_else(is.na(Live_Skin_Prob_2), "", paste0(sprintf("%.0f", Live_Skin_Prob_2 * 100), "%")),
      # Create vs. display
      VS = if_else(is.na(Player_2), "", "vs."),
      Team_2_Display = if_else(is.na(Team_2), "", Team_2),
      Pick_2_Display = if_else(is.na(Pick_2), "", Pick_2)
    ) %>%
    # Select final columns
    select(
      Player = Player_1_Display,
      Team = Team_1,
      Pick = Pick_1,
      `Won Skin` = Won_1,
      `Live Skin Prob` = Live_Prob_1_Display, 
      VS,
      `Player 2` = Player_2_Display,
      `Team 2` = Team_2_Display,
      `Pick 2` = Pick_2_Display,
      `Won Skin 2` = Won_2,
      `Live Skin Prob 2` = Live_Prob_2_Display, 
      Status
    )
  
  # Create the table with HTML formatting enabled
  knitr::kable(
    matchup_table,
    align = 'c',
    caption = "Head-to-Head Matchups",
    escape = FALSE,
    format = "html"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
  
} else {
  cat("No games scheduled for today.")
}
```

```{r zero_sum_table}
#| echo: false
#| message: false
#| warning: false

# Create Zero-Sum Matchups Table
if (nrow(todays_picks) > 0) {
  
  # Identify zero-sum matchups
  zero_sum_games <- todays_picks %>%
    group_by(game_id) %>%
    filter(
      n() == 2,  # Exactly 2 teams in the game
      (all(Pick == "W") | all(Pick == "L"))  # Both W or both L
    ) %>%
    ungroup()
  
  if (nrow(zero_sum_games) > 0) {
    # Build zero-sum table
    zero_sum_table <- zero_sum_games %>%
      group_by(game_id) %>%
      summarise(
        Player_1 = first(Player),
        Team_1 = first(Team),
        Pick_1 = first(Pick),
        Expected_1 = first(`Expected Skins`),
        Won_Skin_1 = first(Won_Skin),
        Player_2 = if(n() > 1) nth(Player, 2) else NA_character_,
        Team_2 = if(n() > 1) nth(Team, 2) else NA_character_,
        Pick_2 = if(n() > 1) nth(Pick, 2) else NA_character_,
        Expected_2 = if(n() > 1) nth(`Expected Skins`, 2) else NA_real_,
        Won_Skin_2 = if(n() > 1) nth(Won_Skin, 2) else NA,
        Status = first(Game_Status),
        .groups = 'drop'
      ) %>%
      mutate(
        # Apply color-coding to Player columns
        Player_1_Display = case_when(
          Status == "Final" & !is.na(Won_Skin_1) & Won_Skin_1 ~ 
            cell_spec(Player_1, background = "#90EE90", color = "#000000 !important", 
                      bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
          Status == "Final" & !is.na(Won_Skin_1) & !Won_Skin_1 ~ 
            cell_spec(Player_1, background = "#FFB6C6", color = "#000000 !important", 
                      bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
          TRUE ~ Player_1
        ),
        Player_2_Display = case_when(
          is.na(Player_2) ~ "",
          Status == "Final" & !is.na(Won_Skin_2) & Won_Skin_2 ~ 
            cell_spec(Player_2, background = "#90EE90", color = "#000000 !important", 
                      bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
          Status == "Final" & !is.na(Won_Skin_2) & !Won_Skin_2 ~ 
            cell_spec(Player_2, background = "#FFB6C6", color = "#000000 !important", 
                      bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
          TRUE ~ Player_2
        )
      ) %>%
      select(
        `Player 1` = Player_1_Display,
        `Team 1` = Team_1,
        `Pick 1` = Pick_1,
        `Expected Skins 1` = Expected_1,
        `Player 2` = Player_2_Display,
        `Team 2` = Team_2,
        `Pick 2` = Pick_2,
        `Expected Skins 2` = Expected_2
      )
    
    cat("\n\n")
    knitr::kable(
      zero_sum_table,
      digits = 2,
      align = 'c',
      caption = "Zero-Sum Matchups (Max 1 Skin Available)",
      escape = FALSE,
      format = "html"
    ) %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
      column_spec(c(4, 8), bold = TRUE)
  }
  
} else {
  cat("")
}
```

```{r completed_games_table}
#| echo: false
#| message: false
#| warning: false

# Print Table 4: Completed Games Summary
if (exists("todays_results") && nrow(todays_results) > 0) {
  completed_games_table <- todays_results %>%
    filter(!is.na(Won_Game)) %>%
    mutate(
      # Calculate Won_Skin first
      Won_Skin = case_when(
        Won_Game == TRUE & Pick == "W" ~ TRUE,
        Won_Game == FALSE & Pick == "L" ~ TRUE,
        is.na(Won_Game) ~ NA,
        TRUE ~ FALSE
      ),
      # Apply color-coding to Player column
      Player_Display = case_when(
        Won_Skin == TRUE ~ 
          cell_spec(Player, background = "#90EE90", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Won_Skin == FALSE ~ 
          cell_spec(Player, background = "#FFB6C6", color = "#000000 !important", 
                    bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player
      ),
      # Convert Won_Game to character for consistency with total row
      Won_Game_Display = as.character(Won_Game)
    ) %>%
    select(
      Player = Player_Display,
      Team,
      Pick,
      `Won Game?` = Won_Game_Display,
      `Actual Skins` = Actual_Skins,
      `Expected Skins`,
      `Skins Luck` = Skins_Luck
    ) %>%
    arrange(Team)
  
  if (nrow(completed_games_table) > 0) {
    # Add TOTAL row
    total_row <- data.frame(
      Player = "TOTAL",
      Team = "",
      Pick = "",
      `Won Game?` = "",
      `Actual Skins` = sum(todays_results %>% filter(!is.na(Won_Game)) %>% pull(Actual_Skins), na.rm = TRUE),
      `Expected Skins` = sum(todays_results %>% filter(!is.na(Won_Game)) %>% pull(`Expected Skins`), na.rm = TRUE),
      `Skins Luck` = sum(todays_results %>% filter(!is.na(Won_Game)) %>% pull(Skins_Luck), na.rm = TRUE),
      check.names = FALSE,
      stringsAsFactors = FALSE
    )
    
    completed_games_with_total <- bind_rows(completed_games_table, total_row)
    
    knitr::kable(completed_games_with_total, digits = 1, align = 'c', caption = "Skins Results for Completed Games", escape = FALSE, format = "html") %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
      column_spec(c(5, 7), bold = TRUE) %>%
      row_spec(nrow(completed_games_with_total), bold = TRUE, background = "#444444")
  } else {
    cat("No games have been completed yet today.")
  }
}
```

```{r expected_team_table}
#| echo: false

# Print Table 3: Today's Expected Skins by Team
if (nrow(todays_picks) > 0) {
  
  # Join with results data to determine if games are complete and skins won
  team_table_data <- todays_picks
  
  # If todays_results exists, join to get Won_Game status
  if (exists("todays_results")) {
    team_table_data <- team_table_data %>%
      left_join(
        todays_results %>% select(Team, Won_Game_final = Won_Game, Actual_Skins_final = Actual_Skins),
        by = "Team"
      ) %>%
      mutate(
        Won_Game = coalesce(Won_Game_final, Won_Game),
        Actual_Skins = coalesce(Actual_Skins_final, Actual_Skins),
        Won_Skin = case_when(
          is.na(Won_Game) ~ NA,
          Won_Game == TRUE & Pick == "W" ~ TRUE,
          Won_Game == FALSE & Pick == "L" ~ TRUE,
          TRUE ~ FALSE
        ),
        # Apply color-coding to Player column
        Player_Display = case_when(
          !is.na(Won_Skin) & Won_Skin == TRUE ~ 
            cell_spec(Player, background = "#90EE90", color = "#000000 !important", 
                      bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
          !is.na(Won_Skin) & Won_Skin == FALSE ~ 
            cell_spec(Player, background = "#FFB6C6", color = "#000000 !important", 
                      bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
          TRUE ~ Player
        )
      ) %>%
      select(-Won_Game_final, -Actual_Skins_final)
  } else {
    # No results yet, use original Player column
    team_table_data <- team_table_data %>%
      mutate(Player_Display = Player)
  }
  
  # Format the table and sort by Player, then Expected Skins within Player
  team_table_data <- team_table_data %>%
    mutate(`Implied Prob` = if_else(is.na(`Implied Prob`), "", paste0(sprintf("%.0f", `Implied Prob` * 100), "%"))) %>%
    select(Team, Pick, `Expected Skins`, Player = Player_Display, Moneyline, `Implied Prob`, Player_Raw = Player) %>%
    arrange(Player_Raw, desc(`Expected Skins`)) %>%
    select(-Player_Raw)
  
  knitr::kable(
    team_table_data, 
    digits = 1, 
    align = 'c',
    caption = "Today's Expected Skins by Team",
    escape = FALSE,  # Important: allows HTML formatting
    format = "html"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(3, bold = TRUE)
} else {
  cat("No games scheduled for today.")
}
```

---

## Yesterday's Results

```{r yesterday_matchup_table}
#| echo: false
#| message: false
#| warning: false
#| results: 'asis'

# FIXED: Scrape actual matchups from date-specific URL, then join with CSV data
yesterday_ct <- today_ct - days(1)
yesterday_file <- file.path(history_dir, paste0(yesterday_ct, ".csv"))

if (file.exists(yesterday_file)) {
  yesterday_data <- read_csv(yesterday_file, show_col_types = FALSE)
  
  if (nrow(yesterday_data) > 0) {
    
    # Scrape yesterday's actual matchups from date-specific URL
    yesterday_url <- paste0("https://plaintextsports.com/nba/", yesterday_ct, "/")
    yesterday_page <- read_html(yesterday_url)
    yesterday_text <- yesterday_page %>% html_element("body") %>% html_text2()
    yesterday_lines <- strsplit(yesterday_text, "\n")[[1]]
    yesterday_boxes <- yesterday_lines[grepl("^\\+", yesterday_lines)]
    
    # Parse game boxes to get actual matchups
    parse_game_box <- function(box) {
      parts <- strsplit(box, "\\|")[[1]]
      status <- str_trim(parts[2])
      team1_line <- str_trim(parts[4])
      team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
      team2_line <- str_trim(parts[6])
      team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
      is_final <- grepl("Final", status, fixed = TRUE)
      
      data.frame(
        Team1 = team1_name,
        Team2 = team2_name,
        Status = status,
        Finished = is_final,
        stringsAsFactors = FALSE
      )
    }
    
    # Get all matchups
    if (length(yesterday_boxes) > 0) {
      yesterday_matchups <- bind_rows(lapply(yesterday_boxes, parse_game_box))
      
      # Standardize team abbreviations
      team_replacements <- c(
        "^GS$" = "GSW", "^NO$" = "NOP", "^NY$" = "NYK",
        "^SA$" = "SAS", "^WSH$" = "WAS"
      )
      
      yesterday_matchups <- yesterday_matchups %>%
        mutate(
          Team1 = str_replace_all(Team1, team_replacements),
          Team2 = str_replace_all(Team2, team_replacements),
          scrape_game_id = paste0("game_", row_number())
        )
      
      # Create lookup: each team to its game_id
      team_to_game <- bind_rows(
        yesterday_matchups %>% select(Abbr = Team1, scrape_game_id),
        yesterday_matchups %>% select(Abbr = Team2, scrape_game_id)
      )
      
      # Join CSV data with game_id from actual matchups
      yesterday_with_game <- yesterday_data %>%
        left_join(team_to_game, by = "Abbr") %>%
        mutate(
          Won_Skin = case_when(
            is.na(Won_Game) ~ NA,
            Pick == "W" & Won_Game == TRUE ~ TRUE,
            Pick == "L" & Won_Game == FALSE ~ TRUE,
            TRUE ~ FALSE
          ),
          Game_Status = ifelse(is.na(Won_Game), "Not Started", "Final")
        ) %>%
        filter(!is.na(scrape_game_id))
      
      # Build the matchup table - ONE ROW PER GAME
      yesterday_matchup_table <- yesterday_with_game %>%
        group_by(scrape_game_id) %>%
        summarise(
          Player_1 = first(Player),
          Team_1 = first(Team),
          Pick_1 = first(Pick),
          Won_Skin_1 = first(Won_Skin),
          Player_2 = if(n() > 1) nth(Player, 2) else NA_character_,
          Team_2 = if(n() > 1) nth(Team, 2) else NA_character_,
          Pick_2 = if(n() > 1) nth(Pick, 2) else NA_character_,
          Won_Skin_2 = if(n() > 1) nth(Won_Skin, 2) else NA,
          Status = first(Game_Status),
          .groups = 'drop'
        ) %>%
        mutate(
          Player_1_Display = case_when(
            !is.na(Won_Skin_1) & Won_Skin_1 == TRUE ~ 
              cell_spec(Player_1, background = "#90EE90", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            !is.na(Won_Skin_1) & Won_Skin_1 == FALSE ~ 
              cell_spec(Player_1, background = "#FFB6C6", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            TRUE ~ Player_1
          ),
          Player_2_Display = case_when(
            is.na(Player_2) ~ "",
            !is.na(Won_Skin_2) & Won_Skin_2 == TRUE ~ 
              cell_spec(Player_2, background = "#90EE90", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            !is.na(Won_Skin_2) & Won_Skin_2 == FALSE ~ 
              cell_spec(Player_2, background = "#FFB6C6", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            TRUE ~ Player_2
          ),
          Won_1 = case_when(
            is.na(Won_Skin_1) ~ "",
            Won_Skin_1 == TRUE ~ "✓ Yes",
            Won_Skin_1 == FALSE ~ "✗ No",
            TRUE ~ ""
          ),
          Won_2 = case_when(
            is.na(Player_2) ~ "",
            is.na(Won_Skin_2) ~ "",
            Won_Skin_2 == TRUE ~ "✓ Yes",
            Won_Skin_2 == FALSE ~ "✗ No",
            TRUE ~ ""
          ),
          VS = if_else(is.na(Player_2), "", "vs."),
          Team_2_Display = if_else(is.na(Team_2), "", Team_2),
          Pick_2_Display = if_else(is.na(Pick_2), "", Pick_2)
        ) %>%
        select(
          Player = Player_1_Display,
          Team = Team_1,
          Pick = Pick_1,
          `Won Skin` = Won_1,
          VS,
          `Player 2` = Player_2_Display,
          `Team 2` = Team_2_Display,
          `Pick 2` = Pick_2_Display,
          `Won Skin 2` = Won_2,
          Status
        )
      
      if (nrow(yesterday_matchup_table) > 0) {
        print(knitr::kable(
          yesterday_matchup_table,
          align = 'c',
          caption = paste0(format(yesterday_ct, "%B %d, %Y"), " - Head-to-Head Matchups"),
          escape = FALSE,
          format = "html"
        ) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE))
        
        yesterday_player_summary <- yesterday_with_game %>%
          group_by(Player) %>%
          summarise(
            Total_Expected_Skins = sum(Expected_Skins, na.rm = TRUE),
            Total_Actual_Skins = sum(Actual_Skins, na.rm = TRUE),
            Skins_Luck_Total = sum(Skins_Luck, na.rm = TRUE),
            .groups = 'drop'
          ) %>%
          rename(
            `Total Expected Skins` = Total_Expected_Skins,
            `Total Actual Skins` = Total_Actual_Skins,
            `Skins Luck` = Skins_Luck_Total
          ) %>%
          arrange(desc(`Skins Luck`)) %>%
          mutate(
            # Apply color coding to Player column
            Player_Display = case_when(
              `Skins Luck` > 0 ~ 
                cell_spec(Player, background = "#90EE90", color = "#000000 !important", 
                          bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
              `Skins Luck` < 0 ~ 
                cell_spec(Player, background = "#FFB6C6", color = "#000000 !important", 
                          bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
              TRUE ~ Player
            )
          ) %>%
          select(
            Player = Player_Display,
            `Total Expected Skins`,
            `Total Actual Skins`,
            `Skins Luck`
          )
        
        # Add TOTAL row
        total_row <- data.frame(
          Player = "TOTAL",
          `Total Expected Skins` = sum(yesterday_with_game$Expected_Skins, na.rm = TRUE),
          `Total Actual Skins` = sum(yesterday_with_game$Actual_Skins, na.rm = TRUE),
          `Skins Luck` = sum(yesterday_with_game$Skins_Luck, na.rm = TRUE),
          check.names = FALSE,
          stringsAsFactors = FALSE
        )
        
        yesterday_player_summary_with_total <- bind_rows(yesterday_player_summary, total_row)
        
        cat("<br>")
        print(knitr::kable(
          yesterday_player_summary_with_total,
          digits = 1,
          align = 'c',
          caption = paste0(format(yesterday_ct, "%B %d"), " - Player Summary"),
          escape = FALSE,
          format = "html"
        ) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
          column_spec(4, bold = TRUE) %>%
          row_spec(nrow(yesterday_player_summary_with_total), bold = TRUE, background = "#444444"))
      }
    }
  }
} else {
  cat(paste0("No data available for ", format(yesterday_ct, "%A, %B %d, %Y"), "."))
}
```

---

## Year-to-Date Cumulative Stats

```{r ytd_setup}
#| echo: false
#| message: false
#| warning: false

# Create/update historical baseline data
historical_file <- file.path(history_dir, "ytd_baseline.csv")

# CORRECTED: Nov 4 baseline data (includes Oct 24 - Nov 4)
# These are the correct cumulative values through Nov 4
ytd_baseline <- tribble(
  ~Player, ~Games, ~Total_Expected_Skins, ~Total_Actual_Skins, ~Cumulative_Skins_Luck,
  "Adam", 38, 24.2, 24, -0.2,
  "Eristeo", 35, 24.6, 23, -1.6,
  "Kenneth", 37, 24.1, 18, -6.1,
  "Brian", 38, 23.6, 25, 1.4,
  "Thomas", 34, 23.3, 16, -7.3,
  "Matt", 36, 26.0, 26, 0.0
)

# Save/overwrite the baseline file
write_csv(ytd_baseline, historical_file)

# CRITICAL FIX: Only write baseline_date.txt if it doesn't exist
# Set it to Nov 5 so that only Nov 5+ data gets added on top of the baseline
baseline_date_file <- file.path(history_dir, "baseline_date.txt")
if (!file.exists(baseline_date_file)) {
  # Set baseline date to Nov 5 - baseline includes everything through Nov 4
  writeLines("2025-11-05", baseline_date_file)
}
baseline_date <- as_date(readLines(baseline_date_file)[1])
```

```{r ytd_cumulative}
#| echo: false
#| message: false
#| warning: false

ytd_data <- data.frame()
all_files <- list.files(history_dir, pattern = "^\\d{4}-\\d{2}-\\d{2}\\.csv$", full.names = TRUE)

if (length(all_files) > 0) {
  valid_files <- all_files[sapply(all_files, function(f) {
    file_date <- as_date(str_extract(basename(f), "\\d{4}-\\d{2}-\\d{2}"))
    return(!is.na(file_date) && file_date >= baseline_date)
  })]
  
  if (length(valid_files) > 0) {
    all_history <- bind_rows(lapply(valid_files, function(f) read_csv(f, show_col_types = FALSE)))
    current_year <- year(today_ct)
    ytd_data <- all_history %>%
      filter(year(Date) == current_year, !is.na(Actual_Skins))
  }
}

if (nrow(ytd_data) > 0) {
  ytd_new_data <- ytd_data %>%
    group_by(Player) %>%
    summarise(
      Games_new = n(),
      Total_Expected_Skins_new = sum(Expected_Skins, na.rm = TRUE),
      Total_Actual_Skins_new = sum(Actual_Skins, na.rm = TRUE),
      Cumulative_Skins_Luck_new = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    )
    
  ytd_baseline_renamed <- ytd_baseline %>%
    rename(
      Games_baseline = Games,
      Total_Expected_Skins_baseline = Total_Expected_Skins,
      Total_Actual_Skins_baseline = Total_Actual_Skins,
      Cumulative_Skins_Luck_baseline = Cumulative_Skins_Luck
    )

  ytd_summary <- ytd_baseline_renamed %>%
    full_join(ytd_new_data, by = "Player") %>%
    mutate(
      Games = coalesce(Games_baseline, 0) + coalesce(Games_new, 0),
      Total_Expected_Skins = coalesce(Total_Expected_Skins_baseline, 0) + coalesce(Total_Expected_Skins_new, 0),
      Total_Actual_Skins = coalesce(Total_Actual_Skins_baseline, 0) + coalesce(Total_Actual_Skins_new, 0),
      Cumulative_Skins_Luck = coalesce(Cumulative_Skins_Luck_baseline, 0) + coalesce(Cumulative_Skins_Luck_new, 0)
    ) %>%
    select(Player, Cumulative_Skins_Luck, Games, Total_Expected_Skins, Total_Actual_Skins) %>%
    mutate(
      Expected_Skins_Pct = if_else(Games == 0, 0, (Total_Expected_Skins / Games) * 100),
      Avg_Skins_Luck_per_Game = if_else(Games == 0, 0, Cumulative_Skins_Luck / Games)
    ) %>%
    rename(
      `Total Expected Skins` = Total_Expected_Skins, `Total Actual Skins` = Total_Actual_Skins,
      `Cumulative Skins Luck` = Cumulative_Skins_Luck, `Expected Skins %` = Expected_Skins_Pct,
      `Avg Skins Luck per Game` = Avg_Skins_Luck_per_Game
    ) %>%
    arrange(desc(`Cumulative Skins Luck`))
  
  # Add Total row
  total_games <- sum(ytd_summary$Games)
  total_expected <- sum(ytd_summary$`Total Expected Skins`)
  total_actual <- sum(ytd_summary$`Total Actual Skins`)
  total_luck <- sum(ytd_summary$`Cumulative Skins Luck`)
  weighted_avg_expected_pct <- if_else(total_games == 0, 0, (total_expected / total_games) * 100)
  weighted_avg_luck <- if_else(total_games == 0, 0, total_luck / total_games)
  
  total_row <- data.frame(
    Player = "TOTAL",
    `Cumulative Skins Luck` = total_luck,
    Games = total_games,
    `Total Expected Skins` = total_expected,
    `Total Actual Skins` = total_actual,
    `Expected Skins %` = weighted_avg_expected_pct,
    `Avg Skins Luck per Game` = weighted_avg_luck,
    check.names = FALSE
  )
  
  ytd_summary_with_total <- bind_rows(ytd_summary, total_row)
  
  # Apply gradient color to Cumulative Skins Luck column
  max_luck <- max(ytd_summary$`Cumulative Skins Luck`, na.rm = TRUE)
  min_luck <- min(ytd_summary$`Cumulative Skins Luck`, na.rm = TRUE)
  
  ytd_summary_with_total <- ytd_summary_with_total %>%
    mutate(
      `Cumulative Skins Luck Display` = if_else(
        Player == "TOTAL",
        as.character(sprintf("%.1f", `Cumulative Skins Luck`)),
        case_when(
          `Cumulative Skins Luck` == 0 ~ as.character(sprintf("%.1f", `Cumulative Skins Luck`)),
          `Cumulative Skins Luck` > 0 ~ {
            intensity <- (`Cumulative Skins Luck` / max_luck)
            # Gradient from white (255,255,255) to green (144,238,144)
            r_val <- as.integer(255 - (111 * intensity))
            g_val <- as.integer(255 - (17 * intensity))
            b_val <- as.integer(255 - (111 * intensity))
            cell_spec(
              sprintf("%.1f", `Cumulative Skins Luck`),
              background = sprintf("rgb(%d, %d, %d)", r_val, g_val, b_val),
              color = "#000000 !important",
              bold = TRUE,
              format = "html",
              extra_css = "color: #000000 !important;"
            )
          },
          `Cumulative Skins Luck` < 0 ~ {
            intensity <- (abs(`Cumulative Skins Luck`) / abs(min_luck))
            # Gradient from white (255,255,255) to red (255,182,198)
            r_val <- 255
            g_val <- as.integer(255 - (73 * intensity))
            b_val <- as.integer(255 - (57 * intensity))
            cell_spec(
              sprintf("%.1f", `Cumulative Skins Luck`),
              background = sprintf("rgb(%d, %d, %d)", r_val, g_val, b_val),
              color = "#000000 !important",
              bold = TRUE,
              format = "html",
              extra_css = "color: #000000 !important;"
            )
          }
        )
      )
    ) %>%
    select(Player, `Cumulative Skins Luck` = `Cumulative Skins Luck Display`, Games, 
           `Total Expected Skins`, `Total Actual Skins`, `Expected Skins %`, `Avg Skins Luck per Game`)
  
  knitr::kable(ytd_summary_with_total, digits = 1, align = 'c', caption = paste0(year(today_ct), " Year-to-Date Cumulative Stats"), escape = FALSE, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(2, bold = TRUE) %>%
    row_spec(nrow(ytd_summary_with_total), bold = TRUE, background = "#444444")

} else {
  ytd_summary <- ytd_baseline %>%
    select(Player, Cumulative_Skins_Luck, Games, Total_Expected_Skins, Total_Actual_Skins) %>%
    mutate(
      Expected_Skins_Pct = if_else(Games == 0, 0, (Total_Expected_Skins / Games) * 100),
      Avg_Skins_Luck_per_Game = if_else(Games == 0, 0, Cumulative_Skins_Luck / Games)
    ) %>%
    rename(
      `Total Expected Skins` = Total_Expected_Skins, `Total Actual Skins` = Total_Actual_Skins,
      `Cumulative Skins Luck` = Cumulative_Skins_Luck, `Expected Skins %` = Expected_Skins_Pct,
      `Avg Skins Luck per Game` = Avg_Skins_Luck_per_Game
    ) %>%
    arrange(desc(`Cumulative Skins Luck`))
  
  # Add Total row for baseline
  total_games <- sum(ytd_summary$Games)
  total_expected <- sum(ytd_summary$`Total Expected Skins`)
  total_actual <- sum(ytd_summary$`Total Actual Skins`)
  total_luck <- sum(ytd_summary$`Cumulative Skins Luck`)
  weighted_avg_expected_pct <- if_else(total_games == 0, 0, (total_expected / total_games) * 100)
  weighted_avg_luck <- if_else(total_games == 0, 0, total_luck / total_games)
  
  total_row <- data.frame(
    Player = "TOTAL",
    `Cumulative Skins Luck` = total_luck,
    Games = total_games,
    `Total Expected Skins` = total_expected,
    `Total Actual Skins` = total_actual,
    `Expected Skins %` = weighted_avg_expected_pct,
    `Avg Skins Luck per Game` = weighted_avg_luck,
    check.names = FALSE
  )
  
  ytd_summary_with_total <- bind_rows(ytd_summary, total_row)
  
  # Apply gradient color to Cumulative Skins Luck column
  max_luck <- max(ytd_summary$`Cumulative Skins Luck`, na.rm = TRUE)
  min_luck <- min(ytd_summary$`Cumulative Skins Luck`, na.rm = TRUE)
  
  ytd_summary_with_total <- ytd_summary_with_total %>%
    mutate(
      `Cumulative Skins Luck Display` = if_else(
        Player == "TOTAL",
        as.character(sprintf("%.1f", `Cumulative Skins Luck`)),
        case_when(
          `Cumulative Skins Luck` == 0 ~ as.character(sprintf("%.1f", `Cumulative Skins Luck`)),
          `Cumulative Skins Luck` > 0 ~ {
            intensity <- (`Cumulative Skins Luck` / max_luck)
            # Gradient from white (255,255,255) to green (144,238,144)
            r_val <- as.integer(255 - (111 * intensity))
            g_val <- as.integer(255 - (17 * intensity))
            b_val <- as.integer(255 - (111 * intensity))
            cell_spec(
              sprintf("%.1f", `Cumulative Skins Luck`),
              background = sprintf("rgb(%d, %d, %d)", r_val, g_val, b_val),
              color = "#000000 !important",
              bold = TRUE,
              format = "html",
              extra_css = "color: #000000 !important;"
            )
          },
          `Cumulative Skins Luck` < 0 ~ {
            intensity <- (abs(`Cumulative Skins Luck`) / abs(min_luck))
            # Gradient from white (255,255,255) to red (255,182,198)
            r_val <- 255
            g_val <- as.integer(255 - (73 * intensity))
            b_val <- as.integer(255 - (57 * intensity))
            cell_spec(
              sprintf("%.1f", `Cumulative Skins Luck`),
              background = sprintf("rgb(%d, %d, %d)", r_val, g_val, b_val),
              color = "#000000 !important",
              bold = TRUE,
              format = "html",
              extra_css = "color: #000000 !important;"
            )
          }
        )
      )
    ) %>%
    select(Player, `Cumulative Skins Luck` = `Cumulative Skins Luck Display`, Games, 
           `Total Expected Skins`, `Total Actual Skins`, `Expected Skins %`, `Avg Skins Luck per Game`)
    
  knitr::kable(ytd_summary_with_total, digits = 1, align = 'c', caption = paste0(year(today_ct), " Year-to-Date Cumulative Stats (Baseline)"), escape = FALSE, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(2, bold = TRUE) %>%
    row_spec(nrow(ytd_summary_with_total), bold = TRUE, background = "#444444")
}
```

```{r ytd_charts}
#| echo: false
#| message: false
#| warning: false
#| fig-width: 10
#| fig-height: 6

# Always generate charts - use baseline + any new data
# Create baseline starting point for charts
baseline_chart_date <- baseline_date - days(1)
baseline_start <- ytd_baseline %>%
  mutate(
    Date = baseline_chart_date,
    Daily_Expected = Total_Expected_Skins,
    Daily_Actual = Total_Actual_Skins,
    Daily_Luck = Cumulative_Skins_Luck
  ) %>%
  select(Player, Date, Daily_Expected, Daily_Actual, Daily_Luck)

# Get new daily data if available
if (exists("ytd_data") && nrow(ytd_data) > 0) {
  daily_data_summarized <- ytd_data %>%
    group_by(Player, Date) %>%
    summarise(
      Daily_Expected = sum(Expected_Skins, na.rm = TRUE),
      Daily_Actual = sum(Actual_Skins, na.rm = TRUE),
      Daily_Luck = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    )
  
  # Combine baseline with new data
  chart_data <- bind_rows(baseline_start, daily_data_summarized) %>%
    arrange(Player, Date) %>%
    group_by(Player) %>%
    mutate(
      Cumulative_Expected = cumsum(Daily_Expected),
      Cumulative_Actual = cumsum(Daily_Actual),
      Cumulative_Luck = cumsum(Daily_Luck)
    ) %>%
    ungroup()
} else {
  # Just use baseline if no new data yet
  chart_data <- baseline_start %>%
    mutate(
      Cumulative_Expected = Daily_Expected,
      Cumulative_Actual = Daily_Actual,
      Cumulative_Luck = Daily_Luck
    )
}

# Chart 1: Cumulative Skins Luck Over Time
p1 <- ggplot(chart_data, aes(x = Date, y = Cumulative_Luck, color = Player, group = Player)) +
  geom_line(size = 1.2) + geom_point(size = 2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  labs(title = "Cumulative Skins Luck Over Time", x = "Date", y = "Cumulative Skins Luck", color = "Player") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "bottom",
    text = element_text(colour = "#FFFFFF"),
    axis.text = element_text(colour = "#FFFFFF"),
    axis.title = element_text(colour = "#FFFFFF"),
    plot.background = element_rect(fill = "#222222", color = NA),
    panel.background = element_rect(fill = "#222222", color = NA),
    legend.background = element_rect(fill = "#222222", color = NA),
    legend.key = element_rect(fill = "#222222", color = NA),
    panel.grid.major = element_line(color = "#444444"),
    panel.grid.minor = element_line(color = "#333333")
  ) +
  scale_color_brewer(palette = "Set2")

print(p1)
cat("\n\n")

# Chart 2: Total Expected Skins Over Time
p2 <- ggplot(chart_data, aes(x = Date, y = Cumulative_Expected, color = Player, group = Player)) +
  geom_line(size = 1.2) + geom_point(size = 2) +
  labs(title = "Total Expected Skins Over Time", x = "Date", y = "Cumulative Expected Skins", color = "Player") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "bottom",
    text = element_text(colour = "#FFFFFF"),
    axis.text = element_text(colour = "#FFFFFF"),
    axis.title = element_text(colour = "#FFFFFF"),
    plot.background = element_rect(fill = "#222222", color = NA),
    panel.background = element_rect(fill = "#222222", color = NA),
    legend.background = element_rect(fill = "#222222", color = NA),
    legend.key = element_rect(fill = "#222222", color = NA),
    panel.grid.major = element_line(color = "#444444"),
    panel.grid.minor = element_line(color = "#333333")
  ) +
  scale_color_brewer(palette = "Set2")

print(p2)
```

---

## Diagnostic Information

```{r diagnostics}
#| echo: false
#| message: false
#| warning: false
#| results: 'asis'

cat("\n### System & Timing Diagnostics\n\n")

if (exists("time_debug_info")) {
  cat("**Time and Timezone Information:**\n\n")
  cat(paste0("- System Time: ", format(time_debug_info$system_time, "%Y-%m-%d %H:%M:%S %Z"), "\n"))
  cat(paste0("- System Timezone: ", time_debug_info$system_timezone, "\n"))
  cat(paste0("- Chicago Time: ", format(time_debug_info$chicago_time, "%Y-%m-%d %H:%M:%S %Z"), "\n"))
  cat(paste0("- Chicago Hour: ", time_debug_info$chicago_hour, "\n"))
  cat(paste0("- Use CSV for Sportsline: ", use_csv_for_sportsline, "\n"))
  if (exists("csv_was_used") && csv_was_used) {
    cat(paste0("- **CSV WAS USED**: ", csv_file_used, "\n"))
  } else {
    cat("- **CSV NOT USED** - Fresh Sportsline scrape performed\n")
  }
  cat("\n\n")
}

if (exists("game_counts_debug")) {
  cat("**Gambletron Game Counts:**\n\n")
  cat(paste0("- Total games scraped: ", game_counts_debug$total_games, "\n"))
  cat(paste0("- NBA games: ", game_counts_debug$nba_games, "\n"))
  cat(paste0("- Live games: ", game_counts_debug$live_games, "\n"))
  cat(paste0("- Starting Later games: ", game_counts_debug$starting_later, "\n"))
  cat(paste0("- Finished games: ", game_counts_debug$finished_games, "\n"))
  cat(paste0("- **Games after date filter (nba_today): ", game_counts_debug$nba_today_count, "**\n"))
  cat(paste0("- Today date filter used: ", game_counts_debug$today_date_filter, "\n"))
  cat("\n\n")
}

cat("\n### Gambletron Scrape Diagnostics\n\n")

cat(paste0("**Current date filter (today_date): ", today_date, "**\n\n"))
cat(paste0("**Current skins_date: ", skins_date, "**\n\n"))

if (exists("gambletron_diagnostics") && nrow(gambletron_diagnostics) > 0) {
  cat("**Raw scraped data from Gambletron:**\n\n")
  cat(paste0("Total games scraped: ", nrow(gambletron_diagnostics), "\n\n"))
  
  # Show ALL games, not just first 10
  diagnostic_table <- gambletron_diagnostics %>%
    select(status, team_1, team_2, team_1_prob, team_2_prob, game_date)
  
  print(knitr::kable(diagnostic_table, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
  
  cat("\n\n")
  
  # Check for any games with "Denver" or "Sacramento" or "Nuggets" or "Kings"
  den_sac_games <- gambletron_diagnostics %>%
    filter(
      str_detect(team_1, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE)) |
      str_detect(team_2, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE))
    )
  
  if (nrow(den_sac_games) > 0) {
    cat("**Games involving Denver/Nuggets or Sacramento/Kings:**\n\n")
    print(knitr::kable(
      den_sac_games %>% select(status, team_1, team_2, team_1_prob, team_2_prob, game_date),
      format = "html"
    ) %>%
      kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
    cat("\n\n")
  } else {
    cat("**WARNING: No games found with Denver/Nuggets or Sacramento/Kings in scraped data!**\n\n")
  }
}

cat("**Thomas's picks and calculated Live Expected Skins:**\n\n")

if (exists("todays_picks") && nrow(todays_picks) > 0) {
  thomas_picks <- todays_picks %>%
    filter(Player == "Thomas") %>%
    select(Team, Pick, `Expected Skins`, Live_Expected_Skins, game_id) %>%
    arrange(game_id)
  
  if (nrow(thomas_picks) > 0) {
    print(knitr::kable(thomas_picks, digits = 3, format = "html") %>%
      kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
    
    cat("\n\n**Analysis:**\n")
    cat("- If Thomas has both teams in same game with opposite picks (W and L), ")
    cat("both Live_Expected_Skins values should be equal (complementary probabilities).\n")
    cat("- After the fix, missing values should be filled from opponent's probability.\n\n")
    
    # Check for same-game opposite picks
    thomas_same_game <- thomas_picks %>%
      group_by(game_id) %>%
      filter(n() == 2) %>%
      summarise(
        teams = paste(Team, collapse = " vs "),
        picks = paste(Pick, collapse = " and "),
        expected_skins = paste(round(`Expected Skins`, 3), collapse = " and "),
        live_skins = paste(ifelse(is.na(Live_Expected_Skins), "NA", as.character(round(Live_Expected_Skins, 3))), collapse = " and "),
        are_equal = ifelse(all(!is.na(Live_Expected_Skins)), abs(diff(Live_Expected_Skins)) < 0.01, NA),
        .groups = 'drop'
      )
    
    if (nrow(thomas_same_game) > 0) {
      cat("**Games where Thomas has both teams:**\n\n")
      print(knitr::kable(thomas_same_game, format = "html") %>%
        kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
      cat("\n\n")
      
      # Add interpretation
      if (any(!thomas_same_game$are_equal, na.rm = TRUE)) {
        cat("**⚠️ WARNING: Live_Expected_Skins values are NOT equal for teams in same game!**\n")
        cat("This indicates either:\n")
        cat("1. One team didn't get matched in Gambletron scrape (team name issue)\n")
        cat("2. Data is from different times/sources\n")
        cat("3. Date filtering is including wrong games\n\n")
      }
    }
  } else {
    cat("Thomas has no picks today.\n")
  }
} else {
  cat("No picks data available.\n")
}

# Add summary of what happened
cat("\n\n### Summary of Data Processing\n\n")
cat(paste0("1. **Sportsline Data Source**: ", ifelse(exists("csv_was_used") && csv_was_used, "CSV file (blackout window)", "Fresh scrape"), "\n"))
cat(paste0("2. **Gambletron Games Scraped**: ", ifelse(exists("game_counts_debug"), game_counts_debug$nba_today_count, "Unknown"), "\n"))
cat(paste0("3. **Teams Matched**: ", ifelse(exists("live_data_final"), nrow(live_data_final), 0), "\n"))
cat(paste0("4. **Thomas's Picks Today**: ", ifelse(exists("thomas_picks"), nrow(thomas_picks), 0), "\n"))
if (exists("thomas_picks") && nrow(thomas_picks) > 0) {
  missing_live <- sum(is.na(thomas_picks$Live_Expected_Skins))
  cat(paste0("5. **Thomas's Picks Missing Live Data**: ", missing_live, "\n"))
  if (missing_live > 0) {
    cat("\n**⚠️ PROBLEM IDENTIFIED**: Some of Thomas's picks are missing Live_Expected_Skins values.\n")
    cat("Check the team matching diagnostics above to see which teams didn't match.\n")
  }
}

cat("\n\n**Team Name Matching Debug:**\n\n")

if (exists("live_data_for_diagnostics") && nrow(live_data_for_diagnostics) > 0) {
  cat("**All team entries after standardization (BEFORE deduplication):**\n\n")
  
  # Show all Denver/Sacramento entries
  den_sac_entries <- live_data_for_diagnostics %>%
    filter(str_detect(Team_Original, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE)) |
           str_detect(Team, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE)))
  
  if (nrow(den_sac_entries) > 0) {
    cat(paste0("Found ", nrow(den_sac_entries), " entries for Denver/Sacramento:\n\n"))
    print(knitr::kable(
      den_sac_entries %>%
        select(Team_Original, Team, live_win_prob, game_pair_id, status) %>%
        arrange(Team, status),
      format = "html",
      digits = 3
    ) %>%
      kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
    cat("\n\n")
  } else {
    cat("**WARNING: No Denver/Sacramento teams found in standardized data!**\n\n")
  }
  
  # Check for duplicate teams
  duplicate_teams <- live_data_for_diagnostics %>%
    group_by(Team) %>%
    filter(n() > 1) %>%
    ungroup() %>%
    arrange(Team, status)
  
  if (nrow(duplicate_teams) > 0) {
    cat("**WARNING: Duplicate team entries detected (multiple games?):**\n\n")
    print(knitr::kable(
      duplicate_teams %>%
        select(Team_Original, Team, live_win_prob, game_pair_id, status),
      format = "html",
      digits = 3
    ) %>%
      kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
    cat("\n\n")
  }
} else if (exists("live_data_standardized") && nrow(live_data_standardized) > 0) {
  cat("Teams after standardization (showing original and standardized names):\n\n")
  
  matching_debug <- live_data_standardized %>%
    select(Team_Original, Team, live_win_prob) %>%
    filter(str_detect(Team_Original, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE)) |
           str_detect(Team, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE)))
  
  if (nrow(matching_debug) > 0) {
    print(knitr::kable(matching_debug, format = "html") %>%
      kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
  } else {
    cat("No Denver/Sacramento teams found in standardized data.\n")
  }
} else {
  cat("No standardized team data available.\n")
}

# Show what actually got joined to todays_picks
if (exists("live_data_final") && nrow(live_data_final) > 0) {
  cat("\n\n**Final data that will be joined to todays_picks:**\n\n")
  
  den_sac_final <- live_data_final %>%
    filter(str_detect(Team, regex("Denver|Nuggets|Sacramento|Kings", ignore_case = TRUE)))
  
  if (nrow(den_sac_final) > 0) {
    print(knitr::kable(
      den_sac_final,
      format = "html",
      digits = 3
    ) %>%
      kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE))
  } else {
    cat("No Denver/Sacramento in final data!\n")
  }
}
```
