---
title: "Today's NBA Skins Picks"
format:
  html:
    self-contained: true
    theme: darkly
    grid:
      body-width: 1200px
    css: |
      table {
        width: auto !important;
        margin-left: auto;
        margin-right: auto;
      }
---

```{r setup}
#| echo: false
#| message: false
#| warning: false
# Load all required packages for the whole document
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rvest, httr, dplyr, tidyr, stringr, lubridate, tibble, knitr, kableExtra, readr, ggplot2)

# Create history directory - use relative path that works in both local and GitHub Actions
history_dir <- "skins_history"
if (!dir.exists(history_dir)) {
  dir.create(history_dir, recursive = TRUE)
}
```

```{r timestamp}
#| echo: false
#| results: 'asis'
ts <- format(Sys.time(), "%A, %B %d, %Y at %I:%M %p %Z", tz = "America/Chicago")
cat(paste0("<p style='font-size:14px; color:#999;'><strong>Last updated:</strong> ", ts, "</p>"))
```

```{r expected_skins_data}
#| echo: false
#| message: false
#| warning: false
# This chunk must run first (invisibly) to create 'todays_picks'
# for the results tables that now appear at the top.

# --- Part 0: Define Time and Data Source ---

# Get current time in Chicago
current_time_ct <- now(tzone = "America/Chicago")
current_hour_ct <- hour(current_time_ct)

# Define the "skins date" based on the 2 AM cutoff.
# A "day" runs from 2:00 AM to 1:59 AM the next morning.
if (current_hour_ct < 2) {
  # If it's 1 AM, it's still "yesterday's" skins date
  skins_date <- as_date(current_time_ct) - days(1)
} else {
  # If it's 2 AM or later, it's "today's" skins date
  skins_date <- as_date(current_time_ct)
}

# Use skins_date as the definitive date for this run
today_ct <- skins_date 
current_year <- year(today_ct)

# Define the 11 PM - 2 AM blackout window for scraping
# 23 = 11 PM, 0 = 12 AM, 1 = 1 AM
is_blackout_window <- current_hour_ct >= 23 | current_hour_ct < 2

# Define draft_data (needs to be available for both branches)
draft_data <- tribble(
  ~Team, ~Matchup_Key, ~abbr, ~skins_pick, ~player,
  "Utah Jazz", "Jazz|Utah", "UTA", "L", "Eristeo",
  "Oklahoma City Thunder", "Thunder|Oklahoma", "OKC", "W", "Matt",
  "Washington Wizards", "Wizards|Washington", "WAS", "L", "Brian",
  "Brooklyn Nets", "Nets|Brooklyn", "BKN", "L", "Adam",
  "Cleveland Cavaliers", "Cavaliers|Cleveland", "CLE", "W", "Thomas",
  "Charlotte Hornets", "Hornets|Charlotte", "CHA", "L", "Brian",
  "Denver Nuggets", "Nuggets|Denver", "DEN", "W", "Thomas",
  "New York Knicks", "Knicks|New York", "NYK", "W", "Adam",
  "Houston Rockets", "Rockets|Houston", "HOU", "W", "Kenneth",
  "Phoenix Suns", "Suns|Phoenix", "PHX", "L", "Eristeo",
  "New Orleans Pelicans", "Pelicans|New Orleans", "NOP", "L", "Matt",
  "Orlando Magic", "Magic|Orlando", "ORL", "W", "Kenneth",
  "Chicago Bulls", "Bulls|Chicago", "CHI", "L", "Thomas",
  "Los Angeles Clippers", "Clippers|LA Clippers", "LAC", "W", "Eristeo",
  "Minnesota Timberwolves", "Timberwolves|Minnesota", "MIN", "W", "Matt",
  "Portland Trail Blazers", "Trail Blazers|Portland", "POR", "L", "Kenneth",
  "Atlanta Hawks", "Hawks|Atlanta", "ATL", "W", "Adam",
  "Los Angeles Lakers", "Lakers|LA Lakers", "LAL", "W", "Adam",
  "Golden State Warriors", "Warriors|Golden State", "GSW", "W", "Kenneth",
  "Sacramento Kings", "Kings|Sacramento", "SAC", "L", "Thomas",
  "Detroit Pistons", "Pistons|Detroit", "DET", "W", "Brian",
  "Indiana Pacers", "Pacers|Indiana", "IND", "L", "Eristeo",
  "Miami Heat", "Heat|Miami", "MIA", "L", "Matt",
  "Philadelphia 76ers", "76ers|Philadelphia", "PHI", "W", "Matt",
  "Toronto Raptors", "Raptors|Toronto", "TOR", "L", "Brian",
  "Milwaukee Bucks", "Bucks|Milwaukee", "MIL", "W", "Brian",
  "San Antonio Spurs", "Spurs|San Antonio", "SAS", "W", "Eristeo",
  "Memphis Grizzlies", "Grizzlies|Memphis", "MEM", "W", "Kenneth",
  "Boston Celtics", "Celtics|Boston", "BOS", "W", "Adam",
  "Dallas Mavericks", "Mavericks|Dallas", "DAL", "W", "Thomas"
)

# --- Part 1: Get Data (Conditional) ---
if (is_blackout_window) {
  # --- BRANCH 1: LOAD FROM CSV (11 PM - 2 AM) ---
  cat("NOTICE: In blackout window (11pm-2am CT). Loading data from CSV for", as.character(skins_date), "\n")
  file_path <- file.path(history_dir, paste0(skins_date, ".csv"))
  
  if (file.exists(file_path)) {
    csv_data <- read_csv(file_path, show_col_types = FALSE)
    
    # Re-format CSV data to match the 'todays_picks' structure
    # We must stub columns that don't exist in the CSV (Moneyline, Implied Prob, game_id)
    todays_picks <- csv_data %>%
      mutate(
        "Expected Skins" = Expected_Skins,
        Moneyline = NA_real_,
        "Implied Prob" = NA_real_,
        # Create a dummy game_id. This assumes the CSV is ordered by game.
        game_id = paste0(Date, "_", ceiling(row_number() / 2))
      ) %>%
      select(Date, Team, Pick, "Expected Skins", Player, Moneyline, "Implied Prob", Abbr, game_id) %>%
      arrange(desc(`Expected Skins`))
      
    cat("Successfully loaded data from:", file_path, "\n")
    
  } else {
    # Blackout window, but no file found. Create an empty table.
    cat("ERROR: In blackout window, but file not found at:", file_path, "\nNo data to display.\n")
    todays_picks <- data.frame(
        Date = as.Date(character()), Team = character(), Pick = character(), 
        `Expected Skins` = double(), Player = character(), Moneyline = double(), 
        `Implied Prob` = double(), Abbr = character(), game_id = character()
      )
  }
  
} else {
  # --- BRANCH 2: SCRAPE FROM WEB (2 AM - 11 PM) ---
  cat("NOTICE: Scraping live data from sportsline.com\n")
  
  # --- Part 1.1: Scrape Expected Odds ---
  url <- paste0("https://www.sportsline.com/nba/odds/money-line/",
                "?t=", format(Sys.time(), "%Y%m%d%H%M%S"))
  googlebot_ua <- "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html"
  page_session <- rvest::session(url, httr::user_agent(googlebot_ua))
  html_content <- rvest::read_html(page_session)
  game_data_raw <- html_content %>% html_element("table") %>% html_table()
  
  # Extract correct columns and clean team names
  game_data <- data.frame(
    Matchup_raw = game_data_raw[[1]],
    consensus = game_data_raw[[3]],
    stringsAsFactors = FALSE
  ) %>%
    mutate(
      # Remove the record (e.g., "2-1") from team names
      Matchup = str_remove(Matchup_raw, "\\d+-\\d+$")
    )

  # --- Part 1.2: Calculate Expected Skins ---
  convert_odds_to_prob <- function(odds) {
    prob <- case_when(
      odds < 0 ~ abs(odds) / (abs(odds) + 100),
      odds > 0 ~ 100 / (odds + 100),
      TRUE ~ NA_real_
    )
    return(prob)
  }
  
  # FIXED: Use word boundaries to prevent "Hornets" from matching "Nets"
  match_team <- function(matchup_str, draft_data) {
    matchup_upper <- str_to_upper(matchup_str)
    for (i in 1:nrow(draft_data)) {
      keys <- str_split(draft_data$Matchup_Key[i], "\\|")[[1]]
      keys_upper <- str_to_upper(keys)
      
      # Check if any of the keys match (with word boundaries)
      for (key in keys_upper) {
        pattern <- paste0("\\b", key, "\\b")
        if (str_detect(matchup_upper, regex(pattern))) {
          return(draft_data$Matchup_Key[i])
        }
      }
    }
    return(NA_character_)
  }
  
  # Parse based on actual structure
  todays_picks <- game_data %>%
    filter(!is.na(Matchup) & Matchup != "") %>%
    mutate(
      row_id = row_number(),
      game_time_str = str_extract(Matchup_raw, 
        "(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+\\d+,\\s+\\d+:\\d+\\s*[AP]M\\s+UTC")
    ) %>%
    # Fill UP because date rows come AFTER team rows
    fill(game_time_str, .direction = "up") %>%
    # Filter out the "Expert Picks" and "Advanced Insights" rows
    filter(!str_detect(Matchup, "Expert Picks|Advanced Insights")) %>%
    # Only keep rows with actual odds (contains +/- numbers)
    filter(str_detect(consensus, "[+-]\\d+")) %>%
    mutate(
      Matchup_Key = vapply(Matchup, match_team, draft_data = draft_data, FUN.VALUE = character(1)),
      game_time_str_with_year = paste(game_time_str, current_year),
      game_time_utc = parse_date_time(
        str_remove(game_time_str_with_year, "\\s+UTC"),
        orders = c("b d, I:M p Y"),
        tz = "UTC"
      ),
      game_time_ct = with_tz(game_time_utc, tzone = "America/Chicago"),
      game_date_ct = as_date(game_time_ct),
      # Create game_id: every 2 consecutive rows are a game
      game_id = paste0(game_date_ct, "_", ceiling(row_number() / 2))
    ) %>%
    # *** THIS IS THE KEY FILTER ***
    # It now filters for games matching the "skins_date" (which is today_ct)
    filter(game_date_ct == today_ct, !is.na(Matchup_Key)) %>%
    mutate(
      # Extract odds from format like "-175Open: -189"
      moneyline = as.numeric(str_extract(consensus, "^[+-]?\\d+")),
      opening_odds = as.numeric(str_extract(consensus, "(?<=Open: )[+-]?\\d+"))
    ) %>%
    # Remove duplicates - keep one row per team per game
    distinct(Matchup_Key, game_id, .keep_all = TRUE) %>%
    mutate(implied_prob = convert_odds_to_prob(moneyline)) %>%
    group_by(game_id) %>%
    mutate(
      total_prob_in_game = sum(implied_prob, na.rm = TRUE),
      prob_no_vig = implied_prob / total_prob_in_game
    ) %>%
    ungroup() %>%
    left_join(draft_data, by = "Matchup_Key") %>%
    filter(!is.na(Team)) %>%
    mutate(
      expected_skins = if_else(skins_pick == "W", prob_no_vig, 1 - prob_no_vig),
      Date = today_ct
    ) %>%
    select(Date, Team, Pick = skins_pick, "Expected Skins" = expected_skins,
           Player = player, Moneyline = moneyline, "Implied Prob" = prob_no_vig,
           Abbr = abbr, game_id) %>%
    arrange(desc(`Expected Skins`))
}

# --- Part 2: Handle Draft Data Mismatch ---
# (This runs for both CSV and Scrape methods)
if (nrow(todays_picks) > 0) {
  teams_in_picks <- unique(todays_picks$Team)
  teams_in_draft <- unique(draft_data$Team)
  
  # Teams that are in picks but not in draft (indicates a mismatch in draft_data)
  unmatched_teams_in_picks <- setdiff(teams_in_picks, teams_in_draft)
  if (length(unmatched_teams_in_picks) > 0) {
    cat("WARNING: Teams in scraped data but not in draft_data:", 
        paste(unmatched_teams_in_picks, collapse = ", "), "\n")
  }
}
```

---

## Today's Results & Skins Luck

This section scrapes `plaintextsports.com/nba` for game results. Games that are final or in-progress will appear here.

```{r matchup_table}
#| echo: false
#| message: false
#| warning: false

# Create Head-to-Head Matchup Table
if (nrow(todays_picks) > 0) {
  
  # Scrape plaintextsports.com for game results
  url_scores <- "https://plaintextsports.com/nba/"
  page_scores <- read_html(url_scores)
  
  # Get all text
  all_text <- page_scores %>%
    html_element("body") %>%
    html_text2()
  
  # Extract score boxes
  all_lines <- strsplit(all_text, "\n")[[1]]
  score_boxes <- all_lines[grepl("^\\+", all_lines)]
  
  # Parse game boxes
  parse_game_box <- function(box) {
    parts <- strsplit(box, "\\|")[[1]]
    status <- str_trim(parts[2])
    
    team1_line <- str_trim(parts[4])
    team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
    team1_score <- suppressWarnings(as.numeric(str_extract(team1_line, "[0-9]+$")))
    
    team2_line <- str_trim(parts[6])
    team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
    team2_score <- suppressWarnings(as.numeric(str_extract(team2_line, "[0-9]+$")))
    
    is_final <- grepl("Final", status, fixed = TRUE)
    
    # Determine if game is in progress: contains Q1-Q4, Half, OT, or time with a colon
    is_in_progress <- grepl("Q[1-4]|Half|OT|\\d+:\\d+", status) & !is_final
    
    data.frame(
      Team1 = team1_name,
      Team2 = team2_name,
      Score1 = team1_score,
      Score2 = team2_score,
      Status = status,
      Finished = is_final,
      InProgress = is_in_progress,
      stringsAsFactors = FALSE
    )
  }
  
  # Parse all games
  if (length(score_boxes) > 0) {
    matchup_game_results <- bind_rows(lapply(score_boxes, parse_game_box))
  } else {
    matchup_game_results <- data.frame()
  }
  
  # Standardize abbreviations: Map scraped names to draft_data names
  team_replacements <- c(
    "^GS$" = "GSW",
    "^NO$" = "NOP",
    "^NY$" = "NYK",
    "^SA$" = "SAS",
    "^WSH$" = "WAS"
  )
  
  if (nrow(matchup_game_results) > 0) {
    matchup_game_results <- matchup_game_results %>%
      mutate(
        Team1 = str_replace_all(Team1, team_replacements),
        Team2 = str_replace_all(Team2, team_replacements)
      )
  }
  
  # Create Won_Game lookup - only final games
  matchup_won_lookup <- data.frame(Abbr = character(), Won_Game = logical(), stringsAsFactors = FALSE)
  matchup_status_lookup <- data.frame(Abbr = character(), GameStatus = character(), stringsAsFactors = FALSE)
  
  if (nrow(matchup_game_results) > 0) {
    # Won_Game lookup for finished games
    finished_games <- matchup_game_results %>% filter(Finished == TRUE)
    
    if (nrow(finished_games) > 0) {
      team_1 <- finished_games %>%
        select(Abbr = Team1, PTS = Score1, Opp_PTS = Score2) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      team_2 <- finished_games %>%
        select(Abbr = Team2, PTS = Score2, Opp_PTS = Score1) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      matchup_won_lookup <- bind_rows(team_1, team_2) %>%
        select(Abbr, Won_Game)
    }
    
    # Status lookup for all games
    all_games_status <- matchup_game_results %>%
      mutate(
        GameStatus = case_when(
          Finished == TRUE ~ "Final",
          InProgress == TRUE ~ str_remove(Status, "^(WA|WB|WC|WD|EA|EB|EC|ED)\\s+"),
          TRUE ~ "Not Started"
        )
      )
    
    team_1_status <- all_games_status %>%
      select(Abbr = Team1, GameStatus)
    
    team_2_status <- all_games_status %>%
      select(Abbr = Team2, GameStatus)
    
    matchup_status_lookup <- bind_rows(team_1_status, team_2_status) %>%
      distinct()
  }
  
  # Build the matchup table - ONE ROW PER GAME
  matchup_prep <- todays_picks %>%
    left_join(matchup_won_lookup, by = "Abbr") %>%
    left_join(matchup_status_lookup, by = "Abbr") %>%
    mutate(
      Won_Skin = case_when(
        Won_Game == TRUE & Pick == "W" ~ TRUE,
        Won_Game == FALSE & Pick == "L" ~ TRUE,
        is.na(Won_Game) ~ NA,
        TRUE ~ FALSE
      ),
      Game_Status = if_else(is.na(GameStatus), "Not Started", GameStatus)
    ) %>%
    arrange(game_id)
  
  # Create one row per game with both players
  matchup_table <- matchup_prep %>%
    group_by(game_id) %>%
    summarise(
      Player_1 = first(Player),
      Team_1 = first(Team),
      Pick_1 = first(Pick),
      Won_Skin_1 = first(Won_Skin),
      Player_2 = if(n() > 1) nth(Player, 2) else NA_character_,
      Team_2 = if(n() > 1) nth(Team, 2) else NA_character_,
      Pick_2 = if(n() > 1) nth(Pick, 2) else NA_character_,
      Won_Skin_2 = if(n() > 1) nth(Won_Skin, 2) else NA,
      Status = first(Game_Status),
      .groups = 'drop'
    ) %>%
    mutate(
      # Format player names with color highlighting using format="html"
      Player_1_Display = case_when(
        Status == "Final" & !is.na(Won_Skin_1) & Won_Skin_1 ~ 
          cell_spec(Player_1, background = "#90EE90", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Status == "Final" & !is.na(Won_Skin_1) & !Won_Skin_1 ~ 
          cell_spec(Player_1, background = "#FFB6C6", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player_1
      ),
      Player_2_Display = case_when(
        is.na(Player_2) ~ "",
        Status == "Final" & !is.na(Won_Skin_2) & Won_Skin_2 ~ 
          cell_spec(Player_2, background = "#90EE90", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        Status == "Final" & !is.na(Won_Skin_2) & !Won_Skin_2 ~ 
          cell_spec(Player_2, background = "#FFB6C6", color = "#000000 !important", bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
        TRUE ~ Player_2
      ),
      # Add checkmarks for Won_Skin status
      Won_1 = case_when(
        is.na(Won_Skin_1) ~ "",
        Won_Skin_1 ~ "✓ Yes",
        TRUE ~ "✗ No"
      ),
      Won_2 = case_when(
        is.na(Player_2) ~ "",
        is.na(Won_Skin_2) ~ "",
        Won_Skin_2 ~ "✓ Yes",
        TRUE ~ "✗ No"
      ),
      # Create vs. display
      VS = if_else(is.na(Player_2), "", "vs."),
      Team_2_Display = if_else(is.na(Team_2), "", Team_2),
      Pick_2_Display = if_else(is.na(Pick_2), "", Pick_2)
    ) %>%
    select(
      Player = Player_1_Display,
      Team = Team_1,
      Pick = Pick_1,
      `Won Skin` = Won_1,
      VS,
      `Player 2` = Player_2_Display,
      `Team 2` = Team_2_Display,
      `Pick 2` = Pick_2_Display,
      `Won Skin 2` = Won_2,
      Status
    )
  
  # Create the table with HTML formatting enabled
  knitr::kable(
    matchup_table,
    align = 'c',
    caption = "Head-to-Head Matchups",
    escape = FALSE,
    format = "html"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
  
} else {
  cat("No games scheduled for today.")
}
```

```{r results_and_luck}
#| echo: false
#| message: false
#| warning: false

# Only process results if we have games today
if (nrow(todays_picks) > 0) {
  
  # 1. Scrape plaintextsports.com for live game data
  url_scores <- "https://plaintextsports.com/nba/"
  page_scores <- read_html(url_scores)
  
  # Get all text from the body
  all_text <- page_scores %>%
    html_element("body") %>%
    html_text2()
  
  # 2. Extract Game Blocks - Split into lines and get score boxes
  all_lines <- strsplit(all_text, "\n")[[1]]
  score_boxes <- all_lines[grepl("^\\+", all_lines)]
  
  # 3. Parse a single game box
  parse_game_box <- function(box) {
    # Split by "|" character
    parts <- strsplit(box, "\\|")[[1]]
    
    # Extract status, teams, and scores
    status <- str_trim(parts[2])
    
    # Team 1
    team1_line <- str_trim(parts[4])
    team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
    team1_score <- suppressWarnings(as.numeric(str_extract(team1_line, "[0-9]+$")))
    
    # Team 2
    team2_line <- str_trim(parts[6])
    team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
    team2_score <- suppressWarnings(as.numeric(str_extract(team2_line, "[0-9]+$")))
    
    # Determine if final
    is_final <- grepl("Final", status, fixed = TRUE)
    
    # Determine if game is in progress
    is_in_progress <- grepl("Q[1-4]|Half|OT|\\d+:\\d+", status) & !is_final
    
    # Return data frame
    data.frame(
      Team1 = team1_name,
      Team2 = team2_name,
      Score1 = team1_score,
      Score2 = team2_score,
      Status = status,
      Finished = is_final,
      InProgress = is_in_progress,
      stringsAsFactors = FALSE
    )
  }
  
  # 4. Parse all game boxes
  if (length(score_boxes) > 0) {
    all_game_results <- bind_rows(lapply(score_boxes, parse_game_box))
  } else {
    all_game_results <- data.frame()
  }
  
  # 5. Standardize team abbreviations to match draft_data
  team_replacements <- c(
    "^GS$" = "GSW",
    "^NO$" = "NOP",
    "^NY$" = "NYK",
    "^SA$" = "SAS",
    "^WSH$" = "WAS"
  )
  
  # Apply standardization
  if (nrow(all_game_results) > 0) {
    all_game_results <- all_game_results %>%
      mutate(
        Team1 = str_replace_all(Team1, team_replacements),
        Team2 = str_replace_all(Team2, team_replacements)
      )
  }
  
  # 6. Create Won_Game lookup - only for finished games
  final_team_results <- data.frame(Abbr = character(), Won_Game = logical(), stringsAsFactors = FALSE)
  
  if (nrow(all_game_results) > 0) {
    finished_games <- all_game_results %>% filter(Finished == TRUE)
    
    if (nrow(finished_games) > 0) {
      # Team 1 results
      team1_results <- finished_games %>%
        select(Abbr = Team1, PTS = Score1, Opp_PTS = Score2) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      # Team 2 results
      team2_results <- finished_games %>%
        select(Abbr = Team2, PTS = Score2, Opp_PTS = Score1) %>%
        mutate(Won_Game = PTS > Opp_PTS)
      
      final_team_results <- bind_rows(team1_results, team2_results) %>%
        select(Abbr, Won_Game)
    }
  }
  
  # 6. Create todays_results with actual outcomes
  todays_results <- todays_picks %>%
    left_join(final_team_results, by = "Abbr") %>%
    mutate(
      Actual_Skins = case_when(
        Won_Game == TRUE & Pick == "W" ~ 1,
        Won_Game == FALSE & Pick == "L" ~ 1,
        is.na(Won_Game) ~ NA_real_,
        TRUE ~ 0
      ),
      Skins_Luck = Actual_Skins - `Expected Skins`
    )
  
  # 7. Save today's results to file (use underscores for easier CSV handling)
  # This now correctly uses today_ct (which is skins_date) as the filename
  today_file <- file.path(history_dir, paste0(today_ct, ".csv"))
  todays_results %>%
    select(Date, Player, Team, Abbr, Pick, Expected_Skins = `Expected Skins`, Won_Game, Actual_Skins, Skins_Luck) %>%
    write_csv(today_file)
  
  # 8. Print Table 4: Completed Games Summary
  completed_games_table <- todays_results %>%
    filter(!is.na(Won_Game)) %>%
    select(
      Player,
      Team,
      Pick,
      `Won Game?` = Won_Game,
      `Actual Skins` = Actual_Skins,
      `Expected Skins`,
      `Skins Luck` = Skins_Luck
    ) %>%
    arrange(Player, Team)
  
  if (nrow(completed_games_table) > 0) {
    knitr::kable(completed_games_table, digits = 1, align = 'c', caption = "Skins Results for Completed Games") %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
      column_spec(c(5, 7), bold = TRUE)
  } else {
    cat("No games have been completed yet today.")
  }
  
} else {
  cat("No games scheduled for today.")
}
```

```{r final_player_summary}
#| echo: false
#| message: false
#| warning: false

# Print Table 5: Final Player Summary
if (exists("todays_results") && nrow(todays_results) > 0) {
  final_player_summary <- todays_results %>%
    group_by(Player) %>%
    summarise(
      `Total Expected Skins` = sum(`Expected Skins`, na.rm = TRUE),
      `Total Actual Skins` = sum(Actual_Skins, na.rm = TRUE),
      `Skins Luck` = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    arrange(desc(`Skins Luck`))
  
  knitr::kable(
    final_player_summary,
    digits = 1,
    align = 'c',
    caption = "Final Player Summary (Expected vs. Actual)"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(4, bold = TRUE)
}
```

---

This page shows the expected skins for today's NBA games, based on live odds.

```{r expected_player_table}
#| echo: false

# Print Table 1: Total Expected Skins by Player
if (nrow(todays_picks) > 0) {
  
  # First, identify self zero-sum matchups (same player has both teams AND both picks are the same)
  self_zero_sum <- todays_picks %>%
    group_by(game_id) %>%
    filter(n() == 2) %>%
    summarise(
      players = list(Player),
      picks = list(Pick),
      is_self_zero_sum = length(unique(Player)) == 1 & length(unique(Pick)) == 1,
      player = first(Player),
      .groups = 'drop'
    ) %>%
    filter(is_self_zero_sum) %>%
    group_by(player) %>%
    summarise(self_zero_sum_count = n(), .groups = 'drop')
  
  # Create player summary
  player_summary <- todays_picks %>%
    group_by(Player) %>%
    summarise(
      `Total Games` = n(),
      `Total Expected Skins` = sum(`Expected Skins`, na.rm = TRUE),
      expected_skins_probs = list(`Expected Skins`),
      .groups = 'drop'
    ) %>%
    left_join(self_zero_sum, by = c("Player" = "player")) %>%
    mutate(
      self_zero_sum_count = ifelse(is.na(self_zero_sum_count), 0, self_zero_sum_count),
      `Max Skins` = `Total Games` - self_zero_sum_count,
      `Expected Skins %` = paste0(sprintf("%.0f", (`Total Expected Skins` / `Total Games`) * 100), "%"),
      # Perfect Skins Probability: only possible if player has exactly 5 games with no self zero-sum
      `Perfect Skins Probability` = ifelse(
        `Max Skins` == 5 & `Total Games` == 5,
        paste0(sprintf("%.0f", prod(unlist(expected_skins_probs)) * 100), "%"),
        "0%"
      )
    ) %>%
    select(Player, `Total Games`, `Total Expected Skins`, `Expected Skins %`, `Max Skins`, `Perfect Skins Probability`) %>%
    arrange(desc(`Total Expected Skins`))
  
  knitr::kable(player_summary, digits = 1, align = 'c', caption = "Total Expected Skins by Player") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
}
```

```{r zero_sum_table}
#| echo: false

# Print Table 2: Zero-Sum Matchups
if (nrow(todays_picks) > 0) {
  zero_sum_games <- todays_picks %>%
    group_by(game_id) %>%
    filter(
      n() == 2, # Exactly 2 teams in the game
      (all(Pick == "W") | all(Pick == "L")) # Both W or both L (creates zero-sum)
    ) %>%
    mutate(
      matchup_type = if_else(all(Pick == "W"), "Both W", "Both L"),
      matchup_str = paste0(Abbr, " (", Player, ")")
    ) %>%
    summarise(
      `Zero-Sum Matchup` = paste(matchup_str, collapse = " vs. "),
      Type = first(matchup_type),
      .groups = 'drop'
    )
  
  if (nrow(zero_sum_games) > 0) {
    knitr::kable(select(zero_sum_games, -game_id), align = 'c', caption = "Today's Zero-Sum Matchups") %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
      row_spec(0, bold = TRUE, color = "white", background = "#444444")
  } else {
    cat("No zero-sum matchups today.")
  }
}
```

```{r expected_team_table}
#| echo: false

# Print Table 3: Today's Expected Skins by Team
if (nrow(todays_picks) > 0) {
  team_table_data <- todays_picks %>%
    mutate(`Implied Prob` = paste0(sprintf("%.0f", `Implied Prob` * 100), "%")) %>%
    select(-game_id, -Abbr, -Date) %>%
    arrange(Player, Team)
  
  knitr::kable(
    team_table_data, 
    digits = 1, 
    align = 'c',
    caption = "Today's Expected Skins by Team"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(3, bold = TRUE)
} else {
  cat("No games scheduled for today.")
}
```

---

## Yesterday's Results

```{r yesterday_matchup_table}
#| echo: false
#| message: false
#| warning: false
#| results: 'asis'

# FIXED: Scrape actual matchups from date-specific URL, then join with CSV data
yesterday_ct <- today_ct - days(1)
yesterday_file <- file.path(history_dir, paste0(yesterday_ct, ".csv"))

if (file.exists(yesterday_file)) {
  yesterday_data <- read_csv(yesterday_file, show_col_types = FALSE)
  
  if (nrow(yesterday_data) > 0) {
    
    # Scrape yesterday's actual matchups from date-specific URL
    yesterday_url <- paste0("https://plaintextsports.com/nba/", yesterday_ct, "/")
    yesterday_page <- read_html(yesterday_url)
    yesterday_text <- yesterday_page %>% html_element("body") %>% html_text2()
    yesterday_lines <- strsplit(yesterday_text, "\n")[[1]]
    yesterday_boxes <- yesterday_lines[grepl("^\\+", yesterday_lines)]
    
    # Parse game boxes to get actual matchups
    parse_game_box <- function(box) {
      parts <- strsplit(box, "\\|")[[1]]
      status <- str_trim(parts[2])
      team1_line <- str_trim(parts[4])
      team1_name <- str_extract(team1_line, "[A-Z]{2,3}")
      team2_line <- str_trim(parts[6])
      team2_name <- str_extract(team2_line, "[A-Z]{2,3}")
      is_final <- grepl("Final", status, fixed = TRUE)
      
      data.frame(
        Team1 = team1_name,
        Team2 = team2_name,
        Status = status,
        Finished = is_final,
        stringsAsFactors = FALSE
      )
    }
    
    # Get all matchups
    if (length(yesterday_boxes) > 0) {
      yesterday_matchups <- bind_rows(lapply(yesterday_boxes, parse_game_box))
      
      # Standardize team abbreviations
      team_replacements <- c(
        "^GS$" = "GSW", "^NO$" = "NOP", "^NY$" = "NYK",
        "^SA$" = "SAS", "^WSH$" = "WAS"
      )
      
      yesterday_matchups <- yesterday_matchups %>%
        mutate(
          Team1 = str_replace_all(Team1, team_replacements),
          Team2 = str_replace_all(Team2, team_replacements),
          game_id = paste0("game_", row_number())
        )
      
      # Create lookup: each team to its game_id
      team_to_game <- bind_rows(
        yesterday_matchups %>% select(Abbr = Team1, game_id),
        yesterday_matchups %>% select(Abbr = Team2, game_id)
      )
      
      # Join CSV data with game_id from actual matchups
      yesterday_with_game <- yesterday_data %>%
        left_join(team_to_game, by = "Abbr") %>%
        mutate(
          Won_Skin = case_when(
            is.na(Won_Game) ~ NA,
            Pick == "W" & Won_Game == TRUE ~ TRUE,
            Pick == "L" & Won_Game == FALSE ~ TRUE,
            TRUE ~ FALSE
          ),
          Game_Status = ifelse(is.na(Won_Game), "Not Started", "Final")
        ) %>%
        filter(!is.na(game_id))
      
      # Build the matchup table - ONE ROW PER GAME
      yesterday_matchup_table <- yesterday_with_game %>%
        group_by(game_id) %>%
        summarise(
          Player_1 = first(Player),
          Team_1 = first(Team),
          Pick_1 = first(Pick),
          Won_Skin_1 = first(Won_Skin),
          Player_2 = if(n() > 1) nth(Player, 2) else NA_character_,
          Team_2 = if(n() > 1) nth(Team, 2) else NA_character_,
          Pick_2 = if(n() > 1) nth(Pick, 2) else NA_character_,
          Won_Skin_2 = if(n() > 1) nth(Won_Skin, 2) else NA,
          Status = first(Game_Status),
          .groups = 'drop'
        ) %>%
        mutate(
          Player_1_Display = case_when(
            !is.na(Won_Skin_1) & Won_Skin_1 == TRUE ~ 
              cell_spec(Player_1, background = "#90EE90", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            !is.na(Won_Skin_1) & Won_Skin_1 == FALSE ~ 
              cell_spec(Player_1, background = "#FFB6C6", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            TRUE ~ Player_1
          ),
          Player_2_Display = case_when(
            is.na(Player_2) ~ "",
            !is.na(Won_Skin_2) & Won_Skin_2 == TRUE ~ 
              cell_spec(Player_2, background = "#90EE90", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            !is.na(Won_Skin_2) & Won_Skin_2 == FALSE ~ 
              cell_spec(Player_2, background = "#FFB6C6", color = "#000000 !important", 
                        bold = TRUE, format = "html", extra_css = "color: #000000 !important;"),
            TRUE ~ Player_2
          ),
          Won_1 = case_when(
            is.na(Won_Skin_1) ~ "",
            Won_Skin_1 == TRUE ~ "✓ Yes",
            Won_Skin_1 == FALSE ~ "✗ No",
            TRUE ~ ""
          ),
          Won_2 = case_when(
            is.na(Player_2) ~ "",
            is.na(Won_Skin_2) ~ "",
            Won_Skin_2 == TRUE ~ "✓ Yes",
            Won_Skin_2 == FALSE ~ "✗ No",
            TRUE ~ ""
          ),
          VS = if_else(is.na(Player_2), "", "vs."),
          Team_2_Display = if_else(is.na(Team_2), "", Team_2),
          Pick_2_Display = if_else(is.na(Pick_2), "", Pick_2)
        ) %>%
        select(
          Player = Player_1_Display,
          Team = Team_1,
          Pick = Pick_1,
          `Won Skin` = Won_1,
          VS,
          `Player 2` = Player_2_Display,
          `Team 2` = Team_2_Display,
          `Pick 2` = Pick_2_Display,
          `Won Skin 2` = Won_2,
          Status
        )
      
      if (nrow(yesterday_matchup_table) > 0) {
        print(knitr::kable(
          yesterday_matchup_table,
          align = 'c',
          caption = paste0(format(yesterday_ct, "%B %d, %Y"), " - Head-to-Head Matchups"),
          escape = FALSE,
          format = "html"
        ) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE))
        
        yesterday_player_summary <- yesterday_with_game %>%
          group_by(Player) %>%
          summarise(
            Total_Expected_Skins = sum(Expected_Skins, na.rm = TRUE),
            Total_Actual_Skins = sum(Actual_Skins, na.rm = TRUE),
            Skins_Luck_Total = sum(Skins_Luck, na.rm = TRUE),
            .groups = 'drop'
          ) %>%
          rename(
            `Total Expected Skins` = Total_Expected_Skins,
            `Total Actual Skins` = Total_Actual_Skins,
            `Skins Luck` = Skins_Luck_Total
          ) %>%
          arrange(desc(`Skins Luck`))
        
        cat("<br>")
        print(knitr::kable(
          yesterday_player_summary,
          digits = 1,
          align = 'c',
          caption = paste0(format(yesterday_ct, "%B %d"), " - Player Summary")
        ) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
          column_spec(4, bold = TRUE))
      }
    }
  }
} else {
  cat(paste0("No data available for ", format(yesterday_ct, "%A, %B %d, %Y"), "."))
}
```

---

## Year-to-Date Cumulative Stats

```{r ytd_setup}
#| echo: false
#| message: false
#| warning: false

# Create/update historical baseline data
historical_file <- file.path(history_dir, "ytd_baseline.csv")

# ALWAYS use the correct baseline data provided by user
ytd_baseline <- tribble(
  ~Player, ~Games, ~Total_Expected_Skins, ~Total_Actual_Skins, ~Cumulative_Skins_Luck,
  "Adam", 24, 15.4, 14, -1.4,
  "Eristeo", 22, 16.9, 17, 0.1,
  "Kenneth", 26, 16.3, 13, -3.3,
  "Brian", 25, 14.9, 18, 3.1,
  "Thomas", 23, 16.1, 12, -4.1,
  "Matt", 24, 16.5, 18, 1.5
)

# Save/overwrite the baseline file
write_csv(ytd_baseline, historical_file)

# Store the baseline date so we only use NEW data going forward
baseline_date_file <- file.path(history_dir, "baseline_date.txt")
writeLines(as.character(today_ct), baseline_date_file)
baseline_date <- as_date(readLines(baseline_date_file)[1])
```

```{r ytd_cumulative}
#| echo: false
#| message: false
#| warning: false

ytd_data <- data.frame()
all_files <- list.files(history_dir, pattern = "^\\d{4}-\\d{2}-\\d{2}\\.csv$", full.names = TRUE)

if (length(all_files) > 0) {
  valid_files <- all_files[sapply(all_files, function(f) {
    file_date <- as_date(str_extract(basename(f), "\\d{4}-\\d{2}-\\d{2}"))
    return(!is.na(file_date) && file_date >= baseline_date)
  })]
  
  if (length(valid_files) > 0) {
    all_history <- bind_rows(lapply(valid_files, function(f) read_csv(f, show_col_types = FALSE)))
    current_year <- year(today_ct)
    ytd_data <- all_history %>%
      filter(year(Date) == current_year, !is.na(Actual_Skins))
  }
}

if (nrow(ytd_data) > 0) {
  ytd_new_data <- ytd_data %>%
    group_by(Player) %>%
    summarise(
      Games_new = n(),
      Total_Expected_Skins_new = sum(Expected_Skins, na.rm = TRUE),
      Total_Actual_Skins_new = sum(Actual_Skins, na.rm = TRUE),
      Cumulative_Skins_Luck_new = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    )
    
  ytd_baseline_renamed <- ytd_baseline %>%
    rename(
      Games_baseline = Games,
      Total_Expected_Skins_baseline = Total_Expected_Skins,
      Total_Actual_Skins_baseline = Total_Actual_Skins,
      Cumulative_Skins_Luck_baseline = Cumulative_Skins_Luck
    )

  ytd_summary <- ytd_baseline_renamed %>%
    full_join(ytd_new_data, by = "Player") %>%
    mutate(
      Games = coalesce(Games_baseline, 0) + coalesce(Games_new, 0),
      Total_Expected_Skins = coalesce(Total_Expected_Skins_baseline, 0) + coalesce(Total_Expected_Skins_new, 0),
      Total_Actual_Skins = coalesce(Total_Actual_Skins_baseline, 0) + coalesce(Total_Actual_Skins_new, 0),
      Cumulative_Skins_Luck = coalesce(Cumulative_Skins_Luck_baseline, 0) + coalesce(Cumulative_Skins_Luck_new, 0)
    ) %>%
    select(Player, Games, Total_Expected_Skins, Total_Actual_Skins, Cumulative_Skins_Luck) %>%
    mutate(Avg_Skins_Luck_per_Game = if_else(Games == 0, 0, Cumulative_Skins_Luck / Games)) %>%
    rename(
      `Total Expected Skins` = Total_Expected_Skins, `Total Actual Skins` = Total_Actual_Skins,
      `Cumulative Skins Luck` = Cumulative_Skins_Luck, `Avg Skins Luck per Game` = Avg_Skins_Luck_per_Game
    ) %>%
    arrange(desc(`Cumulative Skins Luck`))
  
  knitr::kable(ytd_summary, digits = 1, align = 'c', caption = paste0(year(today_ct), " Year-to-Date Cumulative Stats")) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(5, bold = TRUE)

} else {
  ytd_summary <- ytd_baseline %>%
    mutate(Avg_Skins_Luck_per_Game = if_else(Games == 0, 0, Cumulative_Skins_Luck / Games)) %>%
    rename(
      `Total Expected Skins` = Total_Expected_Skins, `Total Actual Skins` = Total_Actual_Skins,
      `Cumulative Skins Luck` = Cumulative_Skins_Luck, `Avg Skins Luck per Game` = Avg_Skins_Luck_per_Game
    ) %>%
    arrange(desc(`Cumulative Skins Luck`))
    
  knitr::kable(ytd_summary, digits = 1, align = 'c', caption = paste0(year(today_ct), " Year-to-Date Cumulative Stats (Baseline)")) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
    column_spec(5, bold = TRUE)
}
```

```{r ytd_charts}
#| echo: false
#| message: false
#| warning: false
#| fig-width: 10
#| fig-height: 6

if (exists("ytd_data") && nrow(ytd_data) > 0) {
  
  daily_data_summarized <- ytd_data %>%
    group_by(Player, Date) %>%
    summarise(
      Daily_Expected = sum(Expected_Skins, na.rm = TRUE),
      Daily_Actual = sum(Actual_Skins, na.rm = TRUE),
      Daily_Luck = sum(Skins_Luck, na.rm = TRUE),
      .groups = 'drop'
    )

  baseline_start <- ytd_baseline %>%
    mutate(
      Date = min(ytd_data$Date) - days(1),
      Daily_Expected = Total_Expected_Skins,
      Daily_Actual = Total_Actual_Skins,
      Daily_Luck = Cumulative_Skins_Luck
    ) %>%
    select(Player, Date, Daily_Expected, Daily_Actual, Daily_Luck)

  chart_data <- daily_data_summarized %>%
    bind_rows(baseline_start) %>%
    arrange(Player, Date) %>%
    group_by(Player) %>%
    mutate(
      Cumulative_Expected = cumsum(Daily_Expected),
      Cumulative_Actual = cumsum(Daily_Actual),
      Cumulative_Luck = cumsum(Daily_Luck)
    ) %>%
    ungroup()
      
  p1 <- ggplot(chart_data, aes(x = Date, y = Cumulative_Luck, color = Player, group = Player)) +
    geom_line(size = 1.2) + geom_point(size = 2) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
    labs(title = "Cumulative Skins Luck Over Time", x = "Date", y = "Cumulative Skins Luck", color = "Player") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      legend.position = "bottom",
      text = element_text(colour = "#FFFFFF"),
      axis.text = element_text(colour = "#FFFFFF"),
      axis.title = element_text(colour = "#FFFFFF"),
      plot.background = element_rect(fill = "#222222", color = NA),
      panel.background = element_rect(fill = "#222222", color = NA),
      legend.background = element_rect(fill = "#222222", color = NA),
      legend.key = element_rect(fill = "#222222", color = NA),
      panel.grid.major = element_line(color = "#444444"),
      panel.grid.minor = element_line(color = "#333333")
    ) +
    scale_color_brewer(palette = "Set2")
  
  print(p1)
  cat("\n\n")
  
  p2 <- ggplot(chart_data, aes(x = Date, y = Cumulative_Expected, color = Player, group = Player)) +
    geom_line(size = 1.2) + geom_point(size = 2) +
    labs(title = "Total Expected Skins Over Time", x = "Date", y = "Cumulative Expected Skins", color = "Player") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      legend.position = "bottom",
      text = element_text(colour = "#FFFFFF"),
      axis.text = element_text(colour = "#FFFFFF"),
      axis.title = element_text(colour = "#FFFFFF"),
      plot.background = element_rect(fill = "#222222", color = NA),
      panel.background = element_rect(fill = "#222222", color = NA),
      legend.background = element_rect(fill = "#222222", color = NA),
      legend.key = element_rect(fill = "#222222", color = NA),
      panel.grid.major = element_line(color = "#444444"),
      panel.grid.minor = element_line(color = "#333333")
    ) +
    scale_color_brewer(palette = "Set2")
  
  print(p2)
} else {
  cat("Not enough data yet to generate time series charts. Charts will appear after tonight's games are completed.")
}
```
